styles импортируется как объект в котором теги выступают как ключи а значением являются уникальные имена классов. 
`{div: "style_div_fguiwiius", h1: "style_h1_sldkjf"}`
это делается для создания уникальных имен классов

классы в reacte подгружаются сразу т.к. у нас сразу загружается вся страница


жизненый цикл компонента:
1. Могтирование (Создание компонента когда он отображается в браузере)
2. Обновление
2.1. Меняются props
2.2 Меняется внутренее состояние( Например с помощью useState)
2.3 Используется Force update(Не рекомендуется для использования)
3. Демонтирование (Разрушение когда компонент уберается со страницы браузера)

`{}` можно разместить такие скобки между тегами и там писать логику js

if else в {} нельзя применить

false, null, undefined -  react игнорирует и не будет отображать. Но если будет возвращена строка или число то react ее отрисует

react выполняет поверхностное сравнение при передаче props. т.е если передается не плоское значение а объект то react сравнивает только ссылку а не значения в объекте.
В таком случае может не произойти обновление компонента если вы передаете объект а не плоское значение

С помощью метода map можно отрисовать из массива данных  массив компонентов

`arr.map((product) => <Product name = {product.name}>)`
и в зависимости сколько в мсассиве данных столько и будкт компонентов.

При отрисовки массива нужно передавать уникальные ключи. Для того что бы небыло лишних перерендеров. реакт начнет сравнивать элементы после изменения по id.  для этого в елемент надо передавать пропс key={id}

key  можно использовать не только в массивах но и в пропсах. что бы происходил перерендер компонента если меняется key то компонент перерендерится.

если при проверке key не поменялся то и компонент не будет перерендериватся.


при работе с svg лучше их оптимизировать в поиске svgo

svg можно импортировать тремя способами:
1.  импортировать как компонент import {ReactComponent as "имя компоненты"} from 'путь до svg' 
	`import {ReactComponent as SvgDown} from './img/svgDown.svg'`  и потом вставляете как компонент `<SvgDown />`
	проблема такого подключения будет если svg состоит из множества компонентов

2. можно сжедать тег  присвоить ему classname и прикрепить в css свойство 
	`<button classname = buttonSvgDown>`
	`background-images: url('./img/svgDown.svg')`
	Проблема такого способа не гибкость изменения свойств svg. так как это уже кнопка с фоном svg
3. импортировать как ссылку на svg которую потом можно использовать в теге img
	`import SvgDown from './img/svgDown.svg'`	
	`<button>`
		`<img src="{SvgDown}" loading='lazy'/>`
	`</button>`
	свойство lazy в img делает так что svg загружается только тогда когда пользователь
	дойдет до них. если не дойдет то и скачиваться они не будут

точно так же можно подключить и png кроме первого способа( только второй и третий) .

в button в onclick можно передать как готовую функцию
`<button onClick={() => {тело функции}}>`
так и отдельно описать функцию а потом просто присвоить выполнение при нажатии
`const foo = () => {тело функции}`
`<button onClick={foo}>`

хук(hook) useState
хук для изменения состояния компонента. происходит перерендр
`let [state, setstate] = useState(initialState)`
state это начальное состояние для следующего шага. при инициализации совподает с
initialState.
setState  функция куда передается новое значение
также в нутрь сетера можно передать функцию которая может вычислять state
в useState тоже можно передать функцию 
`useState(() => {})`