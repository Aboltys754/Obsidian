**Слияние** - это способ Git собрать разветвленную историю воедино. Команда `git merge` позволяет использовать независимые ветки, созданные `git branch`, и объединять их в единую ветку.

Обратите внимание, что все команды, представленные ниже, объединяются в текущую ветвь. Текущая ветвь будет обновлена, чтобы отразить слияние. Опять же, это означает, что `git merge` часто используется в сочетании с `git checkout` для выбора текущей ветви и `git branch -d` для удаления устаревшей целевой ветви.

В наиболее частых случаях использования `git merge` используется для объединения двух ветвей. 

Допустим, у нас есть новая функция, основанная на ветке `main`. Теперь мы хотим объединить эту ветку с `main`.

![](https://ucarecdn.com/af7a32db-1557-4bcc-b3e2-9b7c4e8ee0a5/)

Git автоматически определит алгоритм слияния. 

![](https://ucarecdn.com/2f65567e-76d3-40fc-9b39-e22f82766f51/)

Коммиты слияния отличаются от других коммитов тем, что у них есть два родительских коммита. При создании коммита слияния Git попытается автоматически объединить ветки. Если Git обнаружит фрагмент данных, который изменен в обеих ветвях, он не сможет автоматически объединить их. Этот сценарий является **конфликтом слияния**, и Git потребуется вмешательство пользователя для продолжения. 

### Подготовка к слиянию

Перед выполнением слияния необходимо выполнить несколько подготовительных шагов, чтобы убедиться, что слияние проходит правильно.

#### Подтвердите получение ветки

Выполните `git status`, чтобы убедиться, что `HEAD` указано на правильную ветвь, принимающую слияние (целевая ветвь). При необходимости выполните `git checkout`, чтобы переключиться на целевую ветвь. В нашем случае мы выполним `git checkout main`.

#### Извлеките последние удаленные коммиты

Убедитесь, что целевая ветвь и исходная ветвь обновлены. Выполните `git fetch`, чтобы извлечь последние удаленные коммиты. После завершения выборки убедитесь, что ветка `main` имеет последние обновления, выполнив `git pull`.

### Слияние

После выполнения ранее рассмотренных шагов, слияние можно инициировать, выполнив команду `git merge`, указав название ветки, которая будет объединена с целевой веткой.

#### Быстрая перемотка слияния

Слияние с ускоренной перемоткой может произойти, когда существует линейный путь от вершины текущей ветви до целевой ветви. Вместо "фактического" объединения ветвей, все, что Git должен сделать для интеграции историй, - это переместить (т. е. "перемотать вперед") конец текущей ветви до конца целевой ветви. Это эффективно объединяет истории, поскольку все коммиты, доступные из целевой ветви, теперь доступны через текущую. Например, быстрое перемотка слияния `Some-feature` в `Main` будет выглядеть примерно следующим образом:

![](https://ucarecdn.com/e518d0f7-d850-4dee-96c2-087b540ec0f8/)

Однако быстрое слияние невозможно, если ветви разошлись. Когда нет линейного пути к целевой ветви, у Git нет выбора, кроме как объединить их с помощью трехстороннего слияния. При трехстороннем слиянии используется специальный коммит, чтобы связать воедино две истории. 

![](https://ucarecdn.com/76ab5d66-ec76-4520-9487-0b04ebe1021f/)

Хотя вы можете использовать любую из этих стратегий слияния, многие разработчики предпочитают использовать ускоренные слияния (облегченные за счет перебазирования) для небольших функций или исправлений ошибок, оставляя при этом трехсторонние слияния для интеграции более сложных функций. В последнем случае результирующий коммит слияния служит символическим соединением двух ветвей. 

Пример демонстрирует слияние с быстрой перемоткой вперед. Приведенный ниже код создает новую ветку, добавляет к ней два коммита, затем интегрирует ее в основную строку с помощью слияния с быстрой перемоткой вперед.

```bash
# Создание новой ветки из ветки main
git checkout -b new-feature main

# Редактирование файла
git add <file>
git commit -m "Start a feature"

# Редактирование файла
git add <file>
git commit -m "Finish a feature"

# Слияние в новой ветке 
git checkout main
git merge new-feature
git branch -d new-feature
```

Это обычный рабочий процесс для ветвей, которые используются скорее как способ изолированной разработки, чем организационный инструмент для более сложных функций. Также обратите внимание, что Git не должен жаловаться на `git branch -d`, поскольку новая функция теперь доступна из основной ветки.

В случае, если вам требуется коммит слияния во время быстрой перемотки вперед для целей ведения записей, вы можете выполнить `git merge` с помощью опции `--no-ff`.

```
git merge --no-ff <branch>
```

Эта команда объединяет указанную ветвь с текущей ветвью, но всегда генерирует коммит слияния (даже если это было слияние с ускоренной перемоткой вперед). Это полезно для документирования всех слияний, которые происходят в вашем репозитории.

### Трехстороннее слияние

Следующий пример очень похож на предыдущий, но требует трехстороннего слияния, потому что `main` выполняется во время выполнения функции. Это обычный сценарий для больших функций или для случаев, когда несколько разработчиков работают над проектом одновременно.

```bash
# Создание новой ветки из ветки main
git checkout -b new-feature main

# Редактирование файла
git add <file>
git commit -m "Start a feature"

# Редактирование файла
git add <file>
git commit -m "Finish a feature"

# переключение на главную ветку
git checkout main

# Редактирование файла
git add <file>
git commit -m "Make some super-stable changes to main"

# Объединение в ветке new-feature 
git merge new-feature
git branch -d new-feature
```

Обратите внимание, что Git не может выполнить слияние с быстрой перемоткой вперед, поскольку нет способа перейти `main` вверх `new-feature` без возврата назад.

Для большинства рабочих процессов `new-feature` была бы гораздо более масштабная функция, разработка которой заняла бы много времени, поэтому тем временем в `main` появились бы новые коммиты. Если бы ваша функциональная ветвь была на самом деле такой же маленькой, как в приведенном выше примере, вам, вероятно, было бы лучше перебазировать ее на `main` и выполнить слияние с ускоренной перемоткой вперед. Это предотвращает загромождение истории проекта лишними коммитами слияния.