 
1.  @classmethod позволяет создавать методы которые обращаются непосредственно к атрибутам класса и не могут обращатся к обычным атрибутам экземпляров так как атрибут cls
```
@classmethod  
def validate(cls, arg):  
    return cls.MIN_CORD <= arg <= cls.MAX_CORD
```

2.  @staticmethod это метод который не может обращатся ни к атрибутам класса ни к атрибутам экземпляра. не прописывая ни каких атрибутов кроме тех что мы укажем. нет ни self ни cls.

```
@staticmethod  
def norm2(x, y):  
    return x*x + y*y
```

магическиеметоды начинаются с `__Метод__` двойног подчеркивания и закнчиваются так же

3. `__init__` используется для определения атрибутов которые будут использоваться в классе
лучше всего распологать в самом верху. первым методом
https://habr.com/ru/company/otus/blog/572868/

4. `__new__`  вызывается перед созданием объекта
первый аргумент у него   он ссылается на класс. так же что бы экземпляр появился нужно вернуть 
```
def __new__(cls, *args, **kwargs):  
    print("вызов __new__ для " + str(cls))  
    return super().__new__(cls)
```


5. `__del__` удаляет экземпляр


6. `__dict__` используется для просмотра атрибутов класса или экземпляра

7. `__doc__` описание класса если его наисали в строке при создании класса

8. `__setattr__`
```
__setattr__(self, key, value)  автоматически вызывается при изменении класса


def __setattr__(self, key, value):
	if key == "z":
		raise AttributeError("недопустимое имя атрибута")
	else:
		object.__setattr__(self, key, value) 
		
pt1 = Point(1, 2)
pt1.z = 5
такое создание атрибута вызовет ошибку
	
```

с помощью этого метода можно запретить  созавать какой либо атрибут 
нельзя на выходе использовать вместо `object.__setattr__(self, key, value)` использовать  
`self.x = value` иначе код уйдет в ошибку бесконечной рекурсии 


9. `__getattribute__`
```
__getattribute__(self, item) автоматически вызывается при получении свойства класса с именем item 

def __getattribute__(self, item):
	if item == "x":
		raise ValueError("Доступ запрещен")
	else:
		retern object.__getattribute__(self, item)

pt1 = Point(1, 2)
a = pt1.x

такой вызов вызовет ошибку
```
с помощью этого метода например можно запретить обращатся к какому нибудь методу
для возвращения ответа с этого метода нужно обязательно что бы присутствовала строчка 
`retern object.__getattribute__(self, item)` иначе будет возвращатся None


10. `__getattr__`

```
__getattr__(self, item) автоматически вызывается при получении не существующего свойства item класса

def __getattr__(self, item):
	return False

pt1 = Point(1, 2)
a = pt1.xx

переменой a присвоится значение False
```
с помощью него можно определить что делать при обращении к несуществующему атрибуту что бы код не вываливался в ошибку

11. `__delattr__`

```
__delattr__(self, item) автоматически вызывается при удалении свойства item (не важно существует оно или нет)

def __delattr__(self, item):
	object.__delattr__(self, item)

pt1 = Point(1, 2)
del pt1.x

атрибут x удалится

```

Если не указать `object.__delattr__(self, item)` в методе то метод будет вызыватся но удаление происходить не будет.