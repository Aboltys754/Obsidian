
[[#Стартовая строка запрос (Request Line)]]
[[#Заголовки (Request Headers)]]
[[#Тело запроса (Message Body)]]
[[#Стартовая строка ответ(Status Line)]]
[[#Заголовки ответа (Response Headers)]]
[[#Тело ответа (Message Body)]]
[[#Классификация кодов состояния]]

HTTP-запрос - это сообщение, которое клиент отправляет серверу, чтобы получить данные или выполнить действие. Он состоит из **трёх основных частей**: **Стартовая строка, **Заголовки** и **Тело.**** Давайте познакомимся с этими частями запроса поближе.

## Стартовая строка запрос (Request Line)

Это самая первая строка HTTP-запроса, которая полностью определяет намерение клиента.

Она имеет **строгий формат:** `МЕТОД ПУТЬ ВЕРСИЯ_ПРОТОКОЛА`,  например: `GET /products?category=books&in_stock=true HTTP/1.1`.

Разберем данную строку подробнее:

**МЕТОД** (HTTP Method) определяет тип операции над ресурсом. Он является обязательным и чувствительным к регистру (всегда в верхнем регистре, например GET, POST, PUT, DELETE и тд.).

**ПУТЬ** (Request Target / URI) всегда указывает на конкретный ресурс на сервере. Состоит из параметра пути (это иерархическая структура ресурса, `/users/`, `/search/` и тд) и иногда из параметра запроса (Query-строка начинается с символа `?` и содержит параметры в формате `ключ=значение`, разделённые `&`, например `?age=2&limit=20&sort=-created_at&filter[active]=true)`. 

**ВЕРСИЯ ПРОТОКОЛА** указывает, по каким правилам должен обрабатываться запрос. Основные версии это HTTP/1.0, HTTP/1.1, HTTP/2, HTTP/3.

Рассмотрим следующий пример:

```http
POST /users/42/profile HTTP/1.1
```

В этой стартовой строке запроса мы отправляем `POST` запрос по адресу `/users/42/profile` используя версию протокола `HTTP/1.1`.

## Заголовки (Request Headers)

Это **набор пар `Имя: Значение`**, следующих за стартовой строкой и отделённых от тела сообщения пустой строкой (последовательностью `CRLF`). Каждый заголовок размещается на отдельной строке.

```makefile
Host: api.example.com
Accept: application/json
Authorization: Bearer abc123
```

  
Заголовки передают метаданные, необходимые для корректной обработки запроса, безопасности, управления кэшем и состоянием соединения.

Давайте рассмотрим варианты заголовков:

`Host`**:** Обязателен в HTTP/1.1. Указывает **целевой виртуальный хост** при обслуживании нескольких доменов на одном IP-адресе. Например: один сервер (192.0.2.1) обслуживает два виртуальных хоста `site1.example.com` и `site2.example.com`. Заголовок Host определяет, какой конфигурационный блок виртуального хоста будет активирован сервером. То есть при наличии заголовка `Host: site1.example.com` будет использован конфигурационный блок, содержащий директиву `server_name site1.example.com;` (в случае использования вебсервера Nginx), при обработке данного запроса.

`User-Agent`: Содержит **идентификационную строку клиентского ПО**. Используется для аналитики, адаптации контента, обнаружения ботов. Например веб-аналитика собирает данные о доле мобильных устройств (iPhone, Android) для оптимизации интерфейса.

`Accept`**:** Указывает **допустимые типы содержимого (MIME)**, которые клиент готов принять, с приоритетами. Например наш браузер почти всегда запрашивает страницу: `Accept: text/html`, то есть в виде HTML кода. А API-клиент запрашивает как `Accept: application/json`,  и сервер возвращает соответствующий формат.

`Authorization`: Передаёт **учётные данные** в соответствии со схемой аутентификации. Например после входа в систему клиент получает JWT-токен. И все последующие запросы уже содержат `Authorization: Bearer <token>`.

`Content-Type`: Определяет **формат тела запроса**. Обязателен при наличии тела. Например когда мы выполняем отправку формы, то задается `Content-Type: application/x-www-form-urlencoded`. А при загрузке файла: `Content-Type:multipart/form-data`.

`Content-Length`: Указывает **точный размер тела в байтах**. Используется при фиксированной длине передачи. Например при загрузке изображения 2.1 МБ мы передадим `Content-Length: 2202009`. И сервер читает ровно это количество байт.

`Cache-Control`: Содержит **директивы кэширования**. Управляет поведением кэшей (браузер, прокси, CDN). 

`If-None-Match` / `If-Modified-Since`: Реализуют **условные запросы**. Клиент передаёт идентификатор версии ресурса. Например при повторном открытии страницы браузер передаёт `If-None-Match: "abc123"`. Если ресурс не изменился то сервер отвечает `304 Not Modified`. В этом случае `abc123` это ETag (Entity Tag) уникальный идентификатор конкретной версии ресурса (например, HTML-страницы, изображения, JSON-ответа), который сервер ранее отправил клиенту ресурс с заголовком. Теперь клиент (браузер, приложение и т.д.) возвращает этот ETag обратно в заголовке `If-None-Match`, говоря серверу: "У меня есть версия ресурса с ETag abc123. Отправь мне данные только если текущая версия на сервере отличается (т.е. ETag не совпадает)."

`Cookie`: Передаёт **данные состояния сессии**, ранее установленные через `Set-Cookie`. Например после аутентификации сервер выдаёт `Set-Cookie: session_id=xyz`. Браузер автоматически добавляет `Cookie: session_id=xyz` ко всем запросам.

`Origin` / `Referer`: Указывают **источник запроса**. Используются для **защиты от CSRF** и аналитики. Например форма на `https://example.ru` отправляет запрос, и при получении запроса `Origin: https://example.ru` проверяется сервером.

`Idempotency-Key`: Содержит **уникальный клиентский идентификатор операции**. Гарантирует **идемпотентность при повторных попытках**. Например при оплате картой сеть прервалась, но повторный запрос с тем же `Idempotency-Key` возвращает сохранённый результат. 

## Тело запроса (Message Body)

**Тело запроса** — это **полезная нагрузка (payload)**, содержащая **данные, которые клиент передаёт серверу**. Оно отделяется от заголовков пустой строкой (CRLF) и присутствует только в методах, изменяющих состояние ресурса: POST, PUT, PATCH. По стандарту запрещено в GET, HEAD, OPTIONS, DELETE (хотя технически возможно в DELETE). Рассмотрим основные варианты тела запроса;

  
**1. Создание пользователя через JSON (самый частый случай)**

```http
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json
Content-Length: 68

{"username": "bob", "email": "bob@example.com", "role": "editor"}
```

  
**2. Обновление только email (PATCH + частичный JSON)**

```http
PATCH /api/users/42 HTTP/1.1
Host: example.com
Content-Type: application/json
Content-Length: 32

{"email": "newbob@example.com"}
```

   
**3. Загрузка аватара (multipart/form-data)**

```haskell
POST /api/upload-avatar
Content-Type: multipart/form-data; boundary=----XYZ

------XYZ
Content-Disposition: form-data; name="image"; filename="ava.jpg"
Content-Type: image/jpeg

(binary data)
------XYZ--
```

  
**4. Потоковая передача логов (chunked)**

```http
POST /api/logs/stream HTTP/1.1
Host: monitoring.example.com
Transfer-Encoding: chunked
Content-Type: application/json

1A
{"level":"info","msg":"start"}
2F
{"level":"error","msg":"database timeout","time":"2025-04-05T10:00:00Z"}
0
```

Мы познакомились со структурой HTTP запросов, ее понимание позволяет проектировать корректные API, отлаживать ошибки, обеспечивать безопасность и оптимизировать производительность. А в следующей лекции мы познакомимся со структурой HTTP ответов и узнаем про различные коды состояния HTTP, что они означают и как их правильно использовать.



**HTTP-ответ** - это сообщение, которое сервер отправляет клиенту в ответ на запрос, передавая запрошенные данные или результат выполнения действия. Ответ также состоит из **трёх основных частей**: **Стартовая строка, **Заголовки** и **Тело.**** Формат заголовков и тела одинаковый с HTTP-запросами. Вся разница между ними только в первой строке и в её семантике.

## Стартовая строка ответ(Status Line)

Это первая строка HTTP-ответа, она также имеет **строгий формат**: `ВЕРСИЯ_ПРОТОКОЛА КОД_СОСТОЯНИЯ ОПИСАНИЕ`.

Разберем данную строку подробнее:

**ВЕРСИЯ ПРОТОКОЛА** - HTTP/1.1, HTTP/2, HTTP/3.

**КОД СОСТОЯНИЯ** - трёхзначное число, ключевая часть ответа. Указывает результат обработки запроса.

**ОПИСАНИЕ** - человекочитаемый текст (не обязателен к использованию клиентом). Примеры: OK, Created, Bad Request.

Например первая строка может быть как `HTTP/1.1 201 Created` или `HTTP/1.1 404 Not Found`.

## Заголовки ответа (Response Headers)

**Заголовки ответа** - это **набор пар `Имя: Значение`**, следующих за стартовой строкой и отделённых от тела сообщения пустой строкой (последовательностью `CRLF`). Каждый заголовок размещается на отдельной строке.

Например:

```makefile
Content-Type: application/json
Location: /api/users/42
Set-Cookie: session=abc123; HttpOnly; Secure
```

  
Давайте рассмотрим ключевые заголовки ответа:

`Content-Type`: Указывает **формат тела ответа** (MIME-тип). Обязателен при наличии тела. Например основные типы:

- `Content-Type: application/json` --> клиент парсит JSON.
    
- `Content-Type: text/html; charset=utf-8` --> браузер отображает страницу.
    
- `Content-Type: image/jpeg` --> браузер показывает картинку.
    

`Content-Length`: Указывает **точный размер тела в байтах**. Используется при фиксированной длине. Например `Content-Length: 342` и клиент прочитает ровно `342` байта.

`Location`: Содержит **URL нового или перемещённого ресурса**. Используется с кодами 201, 301, 302, 303, 307, 308. Например мы можем после создания пользователя, переместиться сразу в его профиль (`POST /users` --> `Location: /users/42`).

`Cache-Control`: Содержит **директивы кэширования**. Управляет поведением кэшей (браузер, прокси, CDN). 

`ETag`: Содержит **уникальный идентификатор версии ресурса** (Entity Tag). Это мы рассмотрели в прошлом шаге.

`Set-Cookie`: **Устанавливает cookie** на стороне клиента. Браузер автоматически отправляет их в следующих запросах.

`WWW-Authenticate`: **Требует аутентификации**. Используется с кодом 401 Unauthorized. Например если `WWW-Authenticate: Bearer`, то клиент должен отправить JWT токен.

`Allow`: Указывает **разрешённые HTTP-методы** для ресурса. Используется с кодом 405 Method Not Allowed. Например если указано `Allow: GET, POST`, то PUT запрос вызовет 405 код ответа.

`Access-Control-Allow-Origin`: **это** **CORS-заголовок**. Разрешает кросс-доменные запросы.

`Content-Encoding`: Указывает, сжато ли тело ответа (gzip, br, deflate).

## Тело ответа (Message Body)

Тело - это данные, которые сервер возвращает клиенту. Оно отделяется от заголовков пустой строкой (CRLF) и может быть пустым.

Оно может содержать любую полезную нагрузку: HTML-страницу, JSON/XML, изображение/видео/файл, текст, двоичные данные, где их тип и формат описываются заголовками `Content-Type`, например:

```http
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 27

{"ok": true, "user": "id42"}
```

####   
Когда тело ответа **есть**:

- `200 OK` --> данные пользователя.
    
- `201 Created` --> созданный объект.
    
- `400 Bad Request` --> сообщение об ошибке.
    
- `404 Not Found` --> HTML-страница ошибки.
    

####   
Когда тела ответа **нет**:

- `204 No Content` --> успех, но данных нет.
    
- `304 Not Modified` --> ресурс не изменился.
    
- `401 Unauthorized` --> обычно без тела (но может быть).
    

Теперь, когда мы разобрали структуру HTTP-ответа , строку статуса, заголовки и тело, самое время сосредоточиться на самом важном элементе, который клиент видит первым, это **коды состояния**. 

HTTP-коды состояния (HTTP status codes) — это трёхзначные числа, которые сервер возвращает клиенту в ответе на HTTP-запрос. Они указывают на результат обработки запроса и помогают клиенту понять, был ли запрос обработан успешно или произошла ошибка.

### Классификация кодов состояния:

Коды состояния классифицируются по первой цифре:

- **1xx (Информационные):** Указывают, что запрос получен и сервер продолжает его обработку. Эти коды редко используются в клиентском приложении и обычно их не видно пользователю.
    
- **2xx (Успешные):** Указывают, что запрос был обработан успешно. Наиболее распространённые:
    
    - **200 OK:** Запрос обработан успешно.
        
    - **201 Created:** Создан новый ресурс.
        
    - **204 No Content:** Запрос обработан успешно, но ответ не содержит тела.
        
- **3xx (Перенаправления):** Указывают, что клиент должен выполнить дополнительные действия для получения ресурса. Например, перейти по другому URL.
    
    - **301 Moved Permanently:** Ресурс постоянно перемещен на другой URL.
        
    - **302 Found:** Ресурс временно перемещен на другой URL.
        
    - **304 Not Modified:** Ресурс не изменен с момента последнего запроса.
        
- **4xx (Ошибки клиента):** Указывают на ошибки, допущенные клиентом.
    
    - **400 Bad Request:** Запрос некорректен.
        
    - **401 Unauthorized:** Клиент не авторизован.
        
    - **403 Forbidden:** Клиент не имеет прав доступа к ресурсу.
        
    - **404 Not Found:** Ресурс не найден.
        
    - **405 Method Not Allowed:** Запрошенный HTTP-метод не допустим для этого ресурса.
        
    - **409 Conflict:** Конфликт ресурсов. Например, попытка создать ресурс с уже существующим именем.
        
    - **415 Unsupported Media Type:** Сервер не поддерживает тип медиаданных, указанный в запросе.
        
    - **418 I'm a teapot:** Шуточный код ошибки. Сообщает о том, что сервер не может приготовить кофе, потому что он является чайником.
        
    - **422 Unprocessable Entity:** Запрос понятен, но сервер не может его обработать из-за невалидных данных.
        
- **5xx (Ошибки сервера):** Указывают на ошибки, допущенные сервером.
    
    - **500 Internal Server Error:** Произошла внутренняя ошибка сервера.
        
    - **502 Bad Gateway:** Сервер получил неправильный ответ от прокси-сервера или другого сервера.
        
    - **503 Service Unavailable:** Сервер временно недоступен.
        
    - **504 Gateway Timeout:** Сервер не получил ответ от прокси-сервера или другого сервера в течение определенного времени.