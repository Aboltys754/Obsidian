Словарь (`dict`) — это фундаментальная структура данных в Python. Сам язык построен на словарях, они используются повсюду. Несложно заметить, что функционал именованных кортежей можно полностью заменить функционалом словарей. Давайте проведем небольшое сравнение именованных кортежей и словарей по следующим параметрам:

- читабельность (**readability**)
- изменяемость (**mutability**)
- потребление памяти (**memory usage**)
- производительность (**performance**)

### Читабельность

С точки зрения удобочитаемости вы, вероятно, можете сказать, что словари так же читабельны, как и именованные кортежи. Несмотря на то что они не обеспечивают доступа к атрибутам через точечную нотацию, поиск ключей в стиле словаря довольно удобочитаем и прост.

Приведенный ниже код:

```python
from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'height'])

timur = Person('Тимур', 29, 170)

print(timur.name)
print(timur.age)
print(timur.height)
```

без потери читабельности можно заменить на код:

```python
timur = {'name': 'Тимур', 'age': 29, 'height': 170}

print(timur['name'])
print(timur['age'])
print(timur['height'])
```

В обоих примерах мы полностью понимаем код и его назначение. Однако для определения именованного кортежа требуются две дополнительные строки кода: одна строка для импорта фабричной функции `namedtuple()`, а другая — для определения самого именованного кортежа `Person`.

![](https://ucarecdn.com/f472e3bd-12a7-4b73-9b0e-a9fb2c79d750/)Доступ к атрибутам через точечную нотацию выглядит немного аккуратнее чем через квадратные скобки. Также нужно заметить, что при использовании квадратных скобок нам нужно использовать символ кавычки.

### Изменяемость

Большая разница между обеими структурами данных заключается в том, что словари изменяемы, а именованные кортежи неизменны. Это означает, что вы можете изменять словари на месте (подобно спискам), но не можете изменять именованные кортежи (как и обычные кортежи).

Приведенный ниже код:

```python
timur = {'name': 'Тимур', 'age': 29, 'height': 170}
timur['age'] = 30      # изменяем значение в словаре

print(timur['age'])    # выводим измененное значение
```

выводит:

```no-highlight
30
```

 Приведенный ниже код:

```python
from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'height'])

timur = Person('Тимур', 29, 170)
timur.age = 30

print(timur.age)
```

приводит к возникновению ошибки:

```no-highlight
AttributeError: can't set attribute
```

Мы всегда можем **обновить** значение существующего ключа в словаре, но не можем сделать того же самого в именованном кортеже. Мы также можем добавлять новые пары "ключ-значение" в существующие словари, но не можем добавлять пары "поле-значение" в существующие именованные кортежи.

![](https://ucarecdn.com/c207711c-8040-421b-b220-0e68b27a4609/)В именованных кортежах мы можем использовать  метод `_replace()` для обновления значения некоторого поля, но этот метод создает и возвращает новый именованный экземпляр кортежа вместо обновления на месте.

### Потребление памяти

Для сравнения потребления памяти именованным кортежем и словарем мы будем использовать функцию `asizeof()` модуля `pympler`.

Приведенный ниже код:

```python
from collections import namedtuple
from pympler import asizeof

Person = namedtuple('Person', ['name', 'age', 'height'])

timur = Person('Тимур', 29, 170)
timur_dct = {'name': 'Тимур', 'age': 29, 'height': 170}

print(f'Именованный кортеж: {asizeof.asizeof(timur)} байт')
print(f'Словарь: {asizeof.asizeof(timur_dct)} байт')
```

выводит:

```no-highlight
Именованный кортеж: 112 байт
Словарь: 304 байт
```

Именованный кортеж потребляет меньше памяти (примерно на 63%63%), чем эквивалентный словарь. Поэтому, если потребление памяти является ограничением, следует подумать об использовании именованного кортежа вместо словаря.

![](https://ucarecdn.com/ec83093b-b1ab-4cd5-9f8e-52456f0b4edc/)Когда мы сравниваем именованные кортежи и словари, разница в конечном потреблении памяти будет зависеть от количества полей (значений) и их типов. Используя разные значения, мы будем получать разные результаты.

### Производительность

Наконец, нам нужно иметь представление о том, насколько сильно различаются именованные кортежи и словари с точки зрения производительности операций. Для этого мы будем тестировать операции принадлежности и операции доступа к атрибутам.

Приведенный ниже код:

```python
from collections import namedtuple
from time import perf_counter

def average_time(structure, test_func):
    time_measurements = []
    for _ in range(1_000_000):
        start = perf_counter()
        test_func(structure)
        end = perf_counter()
        time_measurements.append(end - start)
    return sum(time_measurements) / len(time_measurements) * int(10**9)

def time_dict(dictionary):
    'name' in dictionary
    'missing_key' in dictionary
    28 in dictionary.values()
    'missing_value' in dictionary.values()
    dictionary['age']

def time_namedtuple(named_tuple):
    'name' in named_tuple._fields
    'missing_field' in named_tuple._fields
    28 in named_tuple
    'missing_value' in named_tuple
    named_tuple.age

Person = namedtuple('Person', ['name', 'age', 'height'])

timur = Person('Тимур', 29, 170)
timur_dct = {'name': 'Тимур', 'age': 29, 'height': 170}

print(f'Именованный кортеж: {average_time(timur, time_namedtuple)} наносекунд')
print(f'Словарь: {average_time(timur_dct , time_dict)} наносекунд')
```

выводит (результат может незначительно отличаться):

```no-highlight
Именованный кортеж: 382 наносекунд
Словарь: 508 наносекунд
```

Таким образом, именованные кортежи работают немного быстрее, чем словари по отношению к операциям принадлежности и доступа к атрибутам.

Итоговая таблица сравнения:

|   |   |   |
|---|---|---|
|**Характеристика / тип**|**Именованный кортеж**|**Словарь**|
|Читабельность **(readability)**|✔️|✔️|
|Изменяемость **(mutability)**|❌|✔️|
|Потребление памяти **(memory usage)**|✔️|❌|
|Производительность **(performance)**|✔️|❌|