1. Встроенные функции `map()`, `filter()`, `reduce()`
2. Модуль `operator`

## Встроенные функции map(), filter(), reduce()

### Встроенная функция map()

Встроенная функция `map()` имеет сигнатуру `map(func, *iterables)`. В отличие от нашей версии из прошлого урока, встроенная функция `map()` может принимать сразу несколько последовательностей, переменное количество аргументов.
```python
def increase(num): 
	return num + 7 
numbers = [1, 2, 3, 4, 5, 6] 
new_numbers = map(increase, numbers) 
for num in new_numbers: # итерируем циклом for 
	print(num)
>>> 8 9 10 11 12 13
```
Чтобы получить из итератора список, нужно воспользоваться функцией `list()`:
```python
new_numbers = list(map(increase, numbers))
```
Функции `map()` можно передать несколько последовательностей. В этом случае в функцию обратного вызова `func` будут передаваться сразу несколько элементов, расположенных в последовательностях на одинаковых позициях.
```python
def func(elem1, elem2, elem3): 
	return elem1 + elem2 + elem3 

numbers1 = [1, 2, 3, 4, 5] 
numbers2 = [10, 20, 30, 40, 50] 
numbers3 = [100, 200, 300, 400, 500] 
new_numbers = list(map(func, numbers1, numbers2, numbers3)) # преобразуем итератор в список 
print(new_numbers)

>>> [111, 222, 333, 444, 555]
```
Если в последовательностях разное количество элементов, то последовательность с минимальным количеством элементов становится ограничителем.
```python
def func(elem1, elem2, elem3): 
	return elem1 + elem2 + elem3 
numbers1 = [1, 2, 3, 4] 
numbers2 = [10, 20] 
numbers3 = [100, 200, 300, 400, 500] 
new_numbers = list(map(func, numbers1, numbers2, numbers3)) # преобразуем итератор в список 
print(new_numbers)
>>>[111, 222]
```
Встроенная функция `map()` реализована очень гибко. В качестве последовательностей мы можем использовать: `списки`, `строки`, `кортежи`, `множества`, `словари`.

```python
circle_areas = [3.56773, 5.57668, 4.31914, 6.20241, 91.01344, 32.01213] 
result1 = list(map(round, circle_areas, [1]*6)) # округляем числа до 1 знака после запятой 
result2 = list(map(round, circle_areas, range(1, 7))) # округляем числа до 1,2,...,6 знаков после запятой 
print(circle_areas) 
print(result1) 
print(result2)
>>>[3.56773, 5.57668, 4.31914, 6.20241, 91.01344, 32.01213] 
>>>[3.6, 5.6, 4.3, 6.2, 91.0, 32.0] 
>>>[3.6, 5.58, 4.319, 6.2024, 91.01344, 32.01213]
```

### Встроенная функция filter()

Встроенная функция `filter()` имеет сигнатуру `filter(func, iterable)`. Она может принимать любой итерируемый объект (список, строку, кортеж, и т.д.).
В качестве параметра `func` указывается ссылка на функцию, которой будет передаваться текущий элемент последовательности. Внутри функции `func` необходимо вернуть значение `True` или `False`
```python
def func(elem): 
	return elem >= 0 
numbers = [-1, 2, -3, 4, 0, -20, 10] 
positive_numbers = list(filter(func, numbers)) # преобразуем итератор в список 
print(positive_numbers)
>>> [2, 4, 0, 10]
```
Встроенной функции `filter()` можно в качестве первого параметра `func` передать значение `None`. В таком случае каждый элемент последовательности будет проверен на соответствие значению `True`. Если элемент в логическом контексте возвращает значение `False`, то он не будет добавлен в возвращаемый результат.
```python
true_values = filter(None, [1, 0, 10, '', None, [], [1, 2, 3], ()]) 
for value in true_values: 
	print(value)
>>> 1 
>>> 10 
>>> [1, 2, 3]
```
### Функция reduce()
Для использования функции `reduce()` необходимо подключить специальный модуль `functools`. Функция `reduce()` имеет сигнатуру `reduce(func, iterable, initializer=None)`. Если начальное значение не установлено, то в его качестве используется первое значение из последовательности `iterable`.
```python
from functools import reduce 
def func(a, b): 
	return a + b 
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
total = reduce(func, numbers, 0) # в качестве начального значения 0 
print(total)
>>> 55
```
Обратите внимание на то, что мы могли вызвать функцию так:
```python
total = reduce(func, numbers) # в качестве начального значения первый элемент списка numbers
```

## Модуль operator
![[Pasted image 20240517163918.png]]

Модуль `operator` реализован на языке `C`, поэтому функции этого модуля работают в разы быстрее, чем самописные функции в Python.