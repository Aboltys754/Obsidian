
## Позиционные аргументы

```python
def diff(x, y): 
	return x - y 
	
res = diff(10, 3) # используем позиционные аргументы 
print(res)
>>>
```
Такой код выведет число 7. При вызове функции `diff()` **первому** параметру `x` будет соответствовать **первый** переданный аргумент, 10, а **второму** параметру `y`  — **второй** аргумент, 3.

## Именованные аргументы

Аргументы, передаваемые с именами, называются **именованными**. При вызове функции можно использовать имена параметров из ее определения.
```python
def diff(x, y): 
	return x - y 
	
res = diff(x=10, y=3) # используем именованные аргументы 
print(res)
```

Когда стоит применять именованные аргументы. Каких-то строгих правил на этот счёт не существует. Однако широко практикуется такой подход: если функция принимает больше трёх аргументов, нужно хотя бы часть из них указать по имени. Особенно важно именовать значения аргументов, когда они относятся к одному типу, ведь без имен очень трудно понять, что делает функция с подобным вызовом.

### Комбинирование позиционных и именованных аргументов

Мы можем вызывать функции, используя именованные и позиционные аргументы одновременно. Но позиционные значения должны быть указаны **до** любых именованных!
```python
res = diff(10, y=3) # используем позиционный и именованный аргумент

res = diff(x=10, 3) # приводит к возникновению ошибки SyntaxError: positional argument follows keyword argument
```

## Необязательные аргументы
Поскольку обычно нам нужно рисовать круг с шириной линии, равной 11 с заливкой, то логично установить данные значения в качестве значений по умолчанию:
```python
def make_circle(x, y, radius, line_width=1, fill=True): 
	# тело функции
```
Теперь для того, чтобы нарисовать стандартный круг, то есть круг имеющий ширину линии, равную 11 с заливкой, мы вызываем функцию так:
```python
make_circle(100, 50, 20)
	или так
make_circle(x=100, y=50, radius=20)
```
### Изменяемые типы в качестве значений по умолчанию

При использовании **изменяемых типов данных** в качестве значения параметра по умолчанию можно столкнуться с неожиданными результатами работы функции.
```python
def append(element, seq=[]): 
	seq.append(element) 
	return seq
print(append(10, [1, 2, 3])) 
print(append(5, [1])) 
print(append(1, [])) 
print(append(3, [4, 5]))
получим ожидаемый вывод:
>>> [1, 2, 3, 10] 
>>> [1, 5] 
>>> [1] 
>>> [4, 5, 3]
```
А если вызовем функцию `append()` так:
```python
print(append(10)) 
print(append(5)) 
print(append(1))

>>> [10] 
>>> [10, 5] 
>>> [10, 5, 1]
```
Значение по умолчанию для параметра создается единожды при определении функции (обычно при загрузке модуля) и становится атрибутом (свойством) функции. Поэтому, если значение по умолчанию изменяемый объект, то его изменение повлияет на каждый следующий вызов функции.
Чтобы посмотреть значения по умолчанию, можно использовать атрибут `__defaults__`.
```python
def append(element, seq=[]): 
	seq.append(element) 
	return seq 
print('Значение по умолчанию', append.__defaults__)
```
Для решения проблемы можно использовать константу `None` в качестве значения параметра по умолчанию, а в теле функции устанавливать нужное значение:
```python
def append(element, seq=None): 
	if seq is None: 
		seq = [] 
	seq.append(element) 
	return seq
```