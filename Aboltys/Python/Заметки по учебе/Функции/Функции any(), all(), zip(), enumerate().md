
1. Функция `all()`
2. Функция `any()`
3. Функция `enumerate()`
4. Функция `zip()`

### Функция all()
Встроенная функция `all()` возвращает значение `True`, если **все элементы** переданной ей последовательности (итерируемого объекта) истинны (приводятся к значению `True`), и `False` в противном случае.

Сигнатура функции следующая: `all(iterable)`. В качестве `iterable` может выступать любой итерируемый объект:
- список;
- кортеж;
- строка;
- множество;
- словарь и т.д.

Напомним, что в Python все следующие значения приводятся к значению `False`:
- константы `None` и `False`;
- нули всех числовых типов данных: `0`, `0.0`, `0j`, `Decimal(0)`, `Fraction(0, 1)`;
- пустые коллекции: `''`, `()`, `[]`, `{}`, `set()`, `range(0)`.

```python
print(all([1, 2, 3])) 
print(all([1, 2, 3, 0, 5])) 
print(all([True, 0, 1])) 
print(all(('', 'red', 'green'))) 
print(all({0j, 3+4j}))
>>> True 
>>> False 
>>> False 
>>> False 
>>> False
```
При работе со словарями функция `all()` проверяет на соответствие параметрам `True` ключи словаря, а не их значения.

Обратите внимание: если переданный итерируемый объект пустой, то функция `all()` возвращает значение `True`.
```python
print(all([])) # передаем пустой список 
print(all(())) # передаем пустой кортеж 
print(all('')) # передаем пустую строку 
print(all([[], []])) # передаем список, содержащий пустые списки
>>> True 
>>> True 
>>> True 
>>> False
```
### Функция any()
Встроенная функция `any()` возвращает значение `True`, если **хотя бы один элемент** переданной ей последовательности (итерируемого объекта) является истинным (приводится к значению `True`), и `False` в противном случае.

Сигнатура функции следующая: `any(iterable)`. В качестве `iterable` может выступать любой итерируемый объект:
- список;
- кортеж;
- строка;
- множество;
- словарь и т.д.
```python
print(any([False, True, False])) # возвращает True, так как есть хотя бы один элемент, равный True 
print(any([False, False, False])) # возвращает False, так как нет элементов, равных True
>>> True 
>>> False
```
```python
print(any([0, 0, 0])) 
print(any([0, 1, 0])) 
print(any([False, 0, 1])) 
print(any(['', [], 'green'])) 
print(any({0j, 3+4j, 0.0}))
>>> False 
>>> True 
>>> True 
>>> True 
>>> True
```
При работе со словарями функция `any()` проверяет на соответствие `True` ключи словаря, а не их значения.
Если переданный объект пуст, то функция `any()` возвращает значение `False`.
```python
print(any([])) # передаем пустой список 
print(any(())) # передаем пустой кортеж 
print(any('')) # передаем пустую строку 
print(any([[], []])) # передаем список, содержащий пустые списки
>>> False 
>>> False 
>>> False 
>>> False
```
### Функции all() и any() в связке с функцией map()

```python
numbers = [17, 90, 78, 56, 231, 45, 5, 89, 91, 11, 19] 
result = all(map(lambda x: True if x > 10 else False, numbers)) 
if result: 
	print('Все числа больше 10') 
else: 
	print('Хотя бы одно число меньше или равно 10')
>>> Хотя бы одно число меньше или равно 10
```
```python
numbers = [17, 91, 78, 55, 231, 45, 5, 89, 99, 11, 19] 
result = any(map(lambda x: x % 2 == 0, numbers)) 
if result: 
	print('Хотя бы одно число четное') 
else: 
	print('Все числа нечетные')
>>> Хотя бы одно число четное
```
## Функция enumerate()
Встроенная функция `enumerate()` возвращает кортеж из индекса элемента и самого элемента переданной ей последовательности (итерируемого объекта).
Сигнатура функции следующая: `enumerate(iterable, start)`. В качестве `iterable` может выступать любой итерируемый объект:

- список;
- кортеж;
- строка;
- множество;
- словарь и т.д.
С помощью необязательного параметра `start` можно задать начальное значение индекса. По умолчанию значение параметра `start = 0`, то есть счет начинается с нуля.

```python
colors = ['red', 'green', 'blue'] 
for pair in enumerate(colors): 
	print(pair)
>>> (0, 'red') 
>>> (1, 'green') 
>>> (2, 'blue')
```
Если счет нужно начать с отличного от нуля числа, то нужно передать значение аргумента `start`.
```python
colors = ['red', 'green', 'blue'] 
for pair in enumerate(colors, 100): 
	print(pair)
>>> (100, 'red') 
>>> (101, 'green') 
>>> (102, 'blue')
```
Обратите внимание, функция `enumerate()` возвращает не список, а специальный объект, который называется итератором. Такой объект похож на список тем, что его можно перебирать циклом `for`, то есть итерировать. Итератор можно преобразовать в список с помощью функции `list()`.
```python
colors = ['red', 'green', 'blue'] 
pairs = enumerate(colors) 
print(pairs) 
print(list(pairs))

>>> <enumerate object at 0x...> 
>>> [(0, 'red'), (1, 'green'), (2, 'blue')]
```
Мы также можем использовать распаковку кортежей при итерировании с помощью цикла `for`.
```python
colors = ['red', 'green', 'blue'] 
for index, item in enumerate(colors): 
	print(index, item)
>>> 0 red 
>>> 1 green 
>>> 2 blue
```
## Функция zip()
Встроенная функция `zip()` объединяет отдельные элементы из каждой переданной ей последовательности (итерируемого объекта) в кортежи.

Сигнатура функции следующая: `zip(*iterables)`. В качестве `iterable` может выступать любой итерируемый объект:

- список;
- кортеж;
- строка;
- множество;
- словарь и т.д.
```python
numbers = [1, 2, 3] 
words = ['one', 'two', 'three'] 
for pair in zip(numbers, words): 
	print(pair)
>>> (1, 'one') 
>>> (2, 'two') 
>>> (3, 'three')
```
Функция `zip()`, как и функция `enumerate()` возвращает не список, а специальный объект, который называется итератором. Такой объект похож на список тем, что его можно перебирать циклом `for`, то есть итерировать. Итератор можно преобразовать в список с помощью функции `list()`.

```python
numbers = [1, 2, 3] 
words = ['one', 'two', 'three'] 
result = zip(numbers, words) 
print(result) 
print(list(result))
>>> <zip object at 0x...> 
>>> [(1, 'one'), (2, 'two'), (3, 'three')]
```
Мы можем передавать функции `zip()` сколько угодно итерируемых объектов.
```python
numbers = [1, 2, 3] 
words = ['one', 'two', 'three'] 
romans = ['I', 'II', 'III'] 
result = zip(numbers, words, romans) 
print(list(result))
>>> [(1, 'one', 'I'), (2, 'two', 'II'), (3, 'three', 'III')]
```
Мы можем передать функции `zip()` даже один итерируемый объект.
```python
numbers = [1, 2, 3] 
result = zip(numbers) 
print(list(result))
>>> [(1,), (2,), (3,)]
```
Если функции `zip()` передать итерируемые объекты, имеющие разную длину, то объект с наименьшим количеством элементов определяет итоговую длину.

```python
numbers = [1, 2, 3, 4] 
words = ['one', 'two'] 
romans = ['I', 'II', 'III'] 
result = zip(numbers, words, romans) 
print(list(result))
>>> [(1, 'one', 'I'), (2, 'two', 'II')]
```
Функция `zip()` удобна для создания словарей, когда ключи и значения находятся в разных списках.
```python
keys = ['name', 'age', 'gender'] 
values = ['Timur', 28, 'male'] 
info = dict(zip(keys, values)) 
print(info)
>>> {'name': 'Timur', 'age': 28, 'gender': 'male'}
```
Функция `zip()` удобна для одновременного (параллельного) итерирования сразу по нескольким коллекциям.
```python
name = ['Timur', 'Ruslan', 'Rustam'] 
age = [28, 21, 19] 
for x, y in zip(name, age): 
	print(x, y)
>>> Timur 28 
>>> Ruslan 21 
>>> Rustam 19
```
Мы можем использовать одновременно функции `zip()` и `enumerate()`:
```python
list1 = ['a1', 'a2', 'a3'] 
list2 = ['b1', 'b2', 'b3'] 
for index, (item1, item2) in enumerate(zip(list1, list2)): 
	print(index, item1, item2)
>>> 0 a1 b1 
>>> 1 a2 b2 
>>> 2 a3 b3
```
