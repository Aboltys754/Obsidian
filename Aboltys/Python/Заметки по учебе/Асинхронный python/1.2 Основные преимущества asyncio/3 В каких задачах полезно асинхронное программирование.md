Асинхронный подход эффективен для задач, связанных с вводом/выводом, т.е. I/O-bound задач. Такой подход может существенно сократить общее время работы приложения, в котором присутствует много задач, время выполнения которых в основном определяется временем выполнения операций ввода/вывода. 

При этом важно понимать, что асинхронный подход оптимизирует не время выполнения этих операций по отдельности, а _**общее** время_ работы программы, которая обычно состоит из множества таких операций.

Операции ввода/вывода — это обычно работа с сетью и файловой системой. Давайте рассмотрим некоторые задачи, которые можно эффективно решать с помощью асинхронного подхода.

_* название модуля asyncio можно расшифровать как асинхронные IO операции._ 

### **Асинхронное программирование в веб-разработке.**

Одной из областей, где асинхронное программирование особенно полезно, является веб-разработка. Веб-серверы часто сталкиваются с большим количеством запросов от клиентов, и каждый запрос может требовать обработки. Если сервер обрабатывает эти запросы последовательно, то есть один за другим, они могут сильно его замедлить, особенно если каждый запрос требует значительного времени обработки.

С помощью асинхронного программирования веб-сервер может обрабатывать множество запросов одновременно, не дожидаясь завершения предыдущего запроса перед тем, как перейти к следующему. Это может значительно улучшить производительность и отклик веб-сервера, особенно при большом количестве одновременных запросов.

### Создание файлового хранилища.

Допустим, что вам поручили создать хостинг файлов — аналог Google-диска. Пользователь загружает файл, а сервис отдаёт ему ссылку, по которой этот файл можно скачать. Пусть сервис сохраняет файл на жёсткий диск, а связку (путь до файла):(ссылка, по которой он доступен) вставляет в базу данных.   

Мы видим в таком задании сразу две очевидные IO-bound операции: (1) запрос к внешней базе данных и (2) запись файла на диск. Кроме этого, в задаче есть несколько неочевидных IO-bound операций — получение файла от пользователя полностью (это происходит по кусочкам) и раздача файла при его скачивании пользователем (тоже по кусочкам). Эти кусочки называются чанками.

- В однопоточном синхронном подходе сервис будет обрабатывать единовременно только один запрос, т.е. одного пользователя, в момент времени. Синхронному сервису предстоит сначала дождаться получения файла на сетевую карту, затем его сохранения в файловую систему, ответа от базы данных, а затем передачи пользователю сгенерированной ссылки на скачивание.   
     
- В асинхронном подходе сервис сможет обрабатывать сразу много запросов **_конкурентно_**, постоянно переключаясь между запросами и ответами при наличии новых данных.

Например, если от пользователя пришёл кусочек файла — сервис сохранит его на жёсткий диск, пришёл ответ от базы данных — отправит пользователю ссылку на файл и так далее с минимальными задержками между этими операциями.

А что если придёт пользователь, который захочет загрузить фильм в качестве 4k и размером 40 GB? Все будут ждать пока загрузится весь файл? 

### Аналогия из реальной жизни.

Представим, что Вы хотите сделать себе кофе с помощью новой кофемашины. Вы не знаете, как ей пользоваться, и поэтому читаете инструкцию, где алгоритм описан по пунктам. 

**_В синхронном_ подходе**: Вы сначала прочитаете всю инструкцию, полностью запомните ее, а затем начнёте делать кофе;

**_В асинхронном_ подходе**: Вы читаете один пункт инструкции, затем выполняете его и сразу же забываете. 

В итоге: асинхронный подход хранит и использует меньше информации (только один пункт инструкции) и в любой момент ожидания может переключиться на другую задачу, а потом продолжить варить себе кофе. 

Однопоточный синхронный сервис столкнётся сразу с двумя проблемами.

- **Во-первых**: пока не будет обработан запрос одного пользователя полностью, сервис будет недоступен для остальных;
- **Во-вторых**: при использовании стандартных подходов предстоит сначала дождаться полной загрузки файла в оперативную память сервера и только после этого начать его обработку. Даже в наше время сервер с 40 GB RAM — достаточно дорогое удовольствие.

Асинхронный сервис обладает возможностью **_стримить_** файл сразу в хранилище по кускам (чанкам). Т.е. при получении нового чанка данных нам нет смысла хранить его у себя, если конечная цель — это запись на диск. Мы можем сразу же сохранить его на диск и очистить память. То есть размер памяти нашей программы всегда остаётся более-менее одинаковым вне зависимости от размера получаемых файлов. Кроме этого, появляется возможность асинхронно обрабатывать каждый кусочек (т.е. прерываться после выполнения очередного пункта инструкции, если проводить аналогию с бытовым примером). Например, можно сообщать о текущем прогрессе загрузки файла через websocket-канал.