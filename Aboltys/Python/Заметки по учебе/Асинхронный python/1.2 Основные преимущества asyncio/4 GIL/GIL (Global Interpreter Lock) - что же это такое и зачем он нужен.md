Несмотря на то, что `asyncio` в стандартном исполнении работает в одном потоке, тема GIL является очень важной для понимания многозадачности в Python. GIL является препятствием для параллельного программирования в Python, которое не так просто обойти. В данном уроке предлагаю более подробно рассмотреть принципы работы с GIL. 

Пока работа идет на одном ядре в одном процессе и в одном потоке (как в большинстве приложений `asyncio`) — все кажется понятным и логичным. Команды и данные попадают в стек, и их обработка происходит в соответствии с работой стека (LIFO: последний пришел — первый ушел). 

Напомню некоторые аспекты работы самого интерпретатора:

1. Любой объект в Python существует, пока существует хотя бы одна ссылка на него; если ссылок нет, то объект будет уничтожен.
2. На самом деле интерпретатор (вернее, его виртуальная машина) выполняет операции, которые не являются атомарными (неделимыми).  
     

Можем посмотреть, сколько всего содержит в себе простейшая функция по сложению двух чисел:

Теперь представим, что никакого контроля за потоками не существует, любой поток может вносить свои изменения в общие данные и принимать решения, нужны ли еще какие-то переменные или их можно отдать сборщику мусора. Во время работы данные изменяются самым непредсказуемым образом, переменные удаляются, возникают ошибки... думаю, что итог работы такой программы вряд ли будет соответствовать нашим ожиданиям.  
Как же все организовать и сделать так, чтобы таких проблем не возникало? Очевидно, что существует несколько возможных путей решения проблемы.

1. Тотальный контроль каждого такого потенциально "узкого" места, отдельная обработка каждой такой ситуации примитивами синхронизации с целью блокировки доступа на изменение каких-то определенных ресурсов. Только вот цена такого контроля может оказаться слишком высока, расходы на контроль могут превысить расходы на выполнение самой программы, многократно вырастает объем кода, сопровождать и вносить изменения в который — то еще удовольствие.  
     
2. Решение, которое используется в Python. Не городить суперсложный огород, а использовать единственную сущность, которая бы могла автоматически разрешать работу одновременно только одному потоку, используя несложный набор правил. Например: пусть первым начнет выполняться тот поток, который первым запросит такую возможность, работающий поток не блокирует "навсегда" работу других потоков, их выполнение должно чередоваться через какое-то время и так далее. Такое решение довольно изящно позволяет "увернуться" от множества сложностей, связанных с многопоточностью, сэкономить ресурсы, писать относительно простой код. Но как всегда есть но, и это - невозможность (по крайней мере на момент написания этого текста) по-настоящему параллельного выполнения потоков в CPython. Сколько бы потоков мы ни создали в своей программе, в любой конкретный момент времени будет выполняться только один из них!

**GIL** был введен, чтобы обеспечить безопасность потоков при работе с памятью. В Python объекты управляются сборщиком мусора, который автоматически освобождает память, когда объект больше не нужен. GIL предотвращает [состояние гонки](https://stepik.org/lesson/933669/step/1?unit=939568) и другие проблемы, связанные с многопоточностью, такие как повреждение структур данных или утечки памяти.

Ситуация с многопоточностью и GIL напоминает игру "Говорящая палка" (Talking Stick), в которой право говорить имеет только тот игрок, в чьих руках и находится палка. По истечении заранее установленного времени он должен передать ее другому игроку. Смысл игры в том, что в итоге каждый игрок получает возможность высказаться, когда приходит его очередь, и не должен мешать другим ораторам.   
  
Так же и с GIL, тот поток, который захватил эту сущность, будет выполняться, а остальные потоки — ждать, когда GIL будет освобожден, чтобы попытаться захватить его самим.

![](https://ucarecdn.com/9f7909bd-b803-4f78-8a84-f767ccf291aa/)

### Когда потоки могут переключаться.

1. CPython переключает потоки, основываясь на *интервале времени, который определяет длительность "квантов" времени, выделенных для выполнения каждого из потоков. Этот интервал может быть настроен и определяет, как часто интерпретатор Python будет проверять возможность переключения между потоками, чтобы обеспечить справедливое распределение процессорного времени.
2. Поток приступает к выполнению I/O операции.
3. Поток завершает свою работу

*_Интервал - это интервал времени, который служит рекомендацией для интерпретатора Python о том, как часто следует рассматривать возможность переключения контекста, однако конкретное решение о переключении потоков и выборе потока для выполнения принимается операционной системой. Операционная система управляет планированием потоков на основе своих алгоритмов и политик, что может привести к переключению потоков вне зависимости от установленного в Python интервала._ Проверить текущее значение интервала можно:

```bash
print(sys.getswitchinterval())  # По умолчанию 0.005 секунды
```

Второй пункт и объясняет различие во времени выполнения I/O и CPU bound задач.

При работе с потоками и наличии операций ввода-вывода (I/O), передача GIL (Global Interpreter Lock) происходит без учета ожидания "внешних" факторов, таких как операции ввода-вывода. Благодаря этому, происходит некоторая параллелизация работы.

![](https://ucarecdn.com/93983bf4-3715-44d3-a65e-99161f80fce2/)