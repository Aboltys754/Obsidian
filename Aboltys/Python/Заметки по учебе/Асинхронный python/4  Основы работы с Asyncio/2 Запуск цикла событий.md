Вы уже использовали данную функцию для запуска корутин, являющихся точкой входа в ваше асинхронное приложение. Рассмотрим функцию более подробно в данном уроке. 

`asyncio.**run**(**coro, *, debug=None, loop_factory=None**)` — функция создаёт цикл событий и запускает указанную корутину в нём. После завершения выполнения **coro** автоматически закрывает цикл событий. Эта функция является основным методом для запуска и управления `asyncio` приложениями. Эту функцию нельзя вызывать, когда другой цикл событий `asyncio` уже работает в том же потоке.

- `**coro**`: **Coroutine** (_корутина_), которую нужно запустить. Это асинхронная функция, которую вы хотите выполнить.
- `**debug**`: (_Необязательный_) Логический флаг, указывающий, следует ли запускать цикл событий в режиме отладки. Если `None`, значение берется из глобальной настройки отладки.
- `**loop_factory**`: (_Необязательный_) представляет собой вызываемый объект (функцию или класс с методом `__call__`), который возвращает экземпляр цикла событий. Это позволяет пользователям предоставлять свою реализацию цикла событий или настроенный экземпляр цикла событий, который может иметь определенные настройки или расширения ( _подробное описание с примером приведено в конце урока_).

### Особенности `asyncio.run()`

**1. Создает и закрывает цикл событий.** Функция создаёт цикл событий и запускает указанный объект `coroutine` в нём. Эта функция является основным методом для запуска и управления `asyncio` приложениями. После завершения выполнения `main()` метод  `asyncio.**run**()` завершает цикл событий и все задачи в нем. Это позволяет изолировать выполнение различных асинхронных операций и управлять ими в контексте определенного цикла событий почти в автоматическом режиме.

При этом все другие корутины, которые могли бы быть запущены в цикле событий, но не завершили свое выполнение до завершения `main()`, также завершат свою работу и выполнены до конца не будут. 

**2. В рамках потока вызывается один раз.** Так как функция является точкой входа для программ на `asyncio`, она должна вызываться только один раз, это связано с тем, что в каждом потоке может быть только один активный цикл событий. Однако вы можете использовать `asyncio.**run**()` в разных потоках с помощью `asyncio.**to_thread**()` _(о которой мы будем говорить позже)_, потому что каждый поток может иметь свой собственный цикл событий (_работа с несколькими потоками вне рамок этого курса_).

**3. `asyncio.run()` нельзя вызвать из корутины.** Это приведет к ошибке, так как функцию нельзя вызывать, когда другой цикл событий `asyncio` уже работает в том же потоке.

```scss
import asyncio


async def nested_run():
    asyncio.run(await asyncio.sleep(1))

async def main():
    await nested_run()

asyncio.run(main())
```

 Вывод:

```vbnet
RuntimeError: asyncio.run() cannot be called from a running event loop
```

**4. Поддержка только корутин**: `asyncio.**run**()` может быть использован только с корутинами. Если вы попытаетесь передать обычную функцию вместо корутины, вы получите ошибку `ValueError`.

**5. Порядок выполнения**: `asyncio.**run**(main())` не гарантирует порядок выполнения асинхронных операций внутри `main()`. Операции вернут результат по факту своего завершения, и порядок завершения их работы далеко не всегда будет совпадать с порядком запуска на исполнение. Есть способ это исправить, но об этом в следующих уроках.

**6. Возвращает результат работы передаваемой корутины.** `asyncio.**run**()` возвращает результат переданной корутины. В примере ниже корутина `main()` является точкой входа, именно внутри нее запускаются остальные корутины и задачи. `asyncio.**run**()` в свою очередь возвращает результат выполнения `main()`.

```python
import asyncio

async def coroutine_1():
    await asyncio.sleep(1)
    print("Корутина 1 выполнена")

async def coroutine_2():
    await asyncio.sleep(2)
    print("Корутина 2 выполнена")

async def main():
    task1 = asyncio.create_task(coroutine_1())
    task2 = asyncio.create_task(coroutine_2())
    await task1
    await task2
    return "Все корутины выполнены"


# Точка входа программы
result = asyncio.run(main())
print(result)
```

Вывод:

```undefined
Корутина 1 выполнена
Корутина 2 выполнена
Все корутины выполнены
```

**7. Ошибка, вызванная в одной из корутин, будет проброшена в вызывающий код.** Если в процессе выполнения функции `main()` произошла ошибка, то `asyncio.**run**(main())` гарантирует, что все остальные асинхронные операции будут отменены, и затем пробросит исключение в вызывающий код.

```python
import asyncio


async def task_func(duration):
    name = asyncio.current_task().get_name()
    print(f'Задача {name} запущена, будет выполнена за {duration} секунд.')
    await asyncio.sleep(duration)
    print(f'Задача {name} завершена.')


async def exсeptor(duration):
    await asyncio.sleep(duration)
    # Здесь возникает исключение
    print(f'Задача {asyncio.current_task().get_name()} вызвала ошибку через {duration} секунды')
    raise Exception("Произошла ошибка в main()")


async def main():
    task1 = asyncio.create_task(task_func(3), name='first')
    task2 = asyncio.create_task(task_func(1), name='second')
    task3 = asyncio.create_task(exсeptor(2), name='exсeption')
    await asyncio.gather(task1, task2, task3)


try:
    asyncio.run(main())
except Exception as e:
    print(f'Было поднято исключение: {e}')
```

Обратите внимание на то, что время вызова исключения находится между завершением первой и второй задачи. После вызова исключения задача с именем `first` не сообщит о своем завершении.  
Вывод:

```sql
Задача first запущена, будет выполнена за 3 секунд.
Задача second запущена, будет выполнена за 1 секунд.
Задача second завершена.
Задача exсeption вызвала ошибку через 2 секунды
Было поднято исключение: Произошла ошибка в main()
```

Вы можете столкнутся с подобной проблемой в  следующих случаях:

- **Сетевые запросы**: при выполнении асинхронных сетевых запросов может произойти исключение (_например, если сервер недоступен_). При этом важно, чтобы все остальные асинхронные запросы были завершены корректно.
    
- **Асинхронные операции ввода/вывода**: при работе с асинхронными операциями ввода/вывода (_например, чтение/запись файлов_) также может произойти исключение (_например, если файл не найден_). В этом случае необходимо гарантировать, что все другие операции ввода/вывода будут завершены корректно, чтобы не потерять данные и не заблокировать ресурсы.
    

**Обработка ошибок и исключений**: в некоторых случаях вы можете обработать ошибку, тем самым позволив вашему коду продолжить выполнение работы после возникновения исключения. В таком случае даже при возникновении исключения все ваши задачи будут корректно завершены.

**Пример кода с обработкой исключений**

Для того, чтобы обработать исключение, необходимо добавить блок `try/except` на потенциально опасном участке кода.

```python
import asyncio


async def task_func(duration):
    name = asyncio.current_task().get_name()
    print(f'Задача {name} запущена, будет выполнена за {duration} секунд.')
    await asyncio.sleep(duration)
    print(f'Задача {name} завершена.')


async def exсeptor(duration):
    # Перехватываем исключение в опасном месте
    try:
        await asyncio.sleep(duration)
        # Здесь возникает исключение
        print(f'Задача {asyncio.current_task().get_name()} вызвала ошибку через {duration} секунды')
        raise Exception("Произошла ошибка")
    except Exception as e:
        print(f'При выполнении задачи {asyncio.current_task().get_name()} было поднято исключение: {e}')


async def main():
    task1 = asyncio.create_task(task_func(3), name='first')
    task2 = asyncio.create_task(task_func(1), name='second')
    task3 = asyncio.create_task(exсeptor(2), name='exсeption')
    await asyncio.gather(task1, task2, task3)


asyncio.run(main())
```

Вывод:

```sql
Задача first запущена, будет выполнена за 3 секунд.
Задача second запущена, будет выполнена за 1 секунд.
Задача second завершена.
Задача exсeption вызвала ошибку через 2 секунды
При выполнении задачи exсeption было поднято исключение: Произошла ошибка
Задача first завершена.
```

В таком случае мы просто получим сообщение об обработанной ошибке, а остальные корутины успешно завершат свою работу. Такой подход может уберечь ваш код от непредвиденных ошибок из запущенных корутин. 

**Изменения в версии 3.12:** Добавлен `loop_factory` параметр.

`loop_factory` — это параметр, который позволяет пользователю указать фабрику для создания нового экземпляра цикла событий, который будет использоваться в `asyncio.run()`. Этот параметр предназначен для расширенной настройки и тестирования, позволяя программистам определить, как именно должен быть создан и сконфигурирован цикл событий.

По умолчанию, если параметр `loop_factory` не указан (т.е., `None`), `asyncio.run()` автоматически создает новый цикл событий, используя стандартную реализацию цикла событий, которая полностью управляется библиотекой `asyncio`. Этот вариант подходит для большинства приложений, где не требуется специальная конфигурация цикла.

Использование пользовательской `loop_factory` позволит вам контролировать создание и настройку цикла событий. Этот вариант может быть полезен для тестирования, когда необходимо имитировать определенные условия, или в ситуациях, когда требуется настроить цикл событий определенным образом, например, для интеграции с другими библиотеками или для оптимизации производительности.

Для создания `loop_factory` вы должны определить функцию или класс, который возвращает экземпляр `asyncio.AbstractEventLoop`.

Пример создания простой пользовательской фабрики цикла событий:

```python
import asyncio

def custom_loop_factory():
    loop = asyncio.new_event_loop()
    # Здесь могут быть добавлены настройки, специфичные для вашего приложения
    return loop
```

Для использования `loop_factory` в `asyncio.run()`, просто передайте вашу фабрику в качестве аргумента при вызове функции:

```python
async def main():
    # Ваш асинхронный код здесь
    pass

# Запуск асинхронной программы с пользовательским циклом событий
asyncio.run(main(), loop_factory=custom_loop_factory)
```

Использование `loop_factory` в `asyncio.run()` представляет собой продвинутую функцию, которая может быть полезна в специфических случаях. Хотя для большинства задач стандартного цикла событий будет вполне достаточно. 

---

 77  3

Шаг 1

Следующий шаг

-  [Комментариев](https://stepik.org/lesson/933677/step/1?unit=939576)
-                              Самые популярные                                         Новые обсуждения                                         Самые обсуждаемые                                         Свежие обновления                      

Будьте вежливы и соблюдайте наши [принципы сообщества](https://help.stepik.org/article/54715). Пожалуйста, не оставляйте решения и подсказки в комментариях, для этого есть отдельный форум.

[![User avatar](https://stepik.org/users/533720595/8f56887fc7255b2fedbc5fa2d19e5a7cc24f6f53/avatar.svg)](https://stepik.org/users/533720595)

Оставить комментарий

[![User avatar](https://cdn.stepik.net/media/users/563972940/1723050398-LMAznOz/avatar.png)](https://stepik.org/users/563972940)

[Олег Сергушев](https://stepik.org/users/563972940)

3 месяца назад

А я думал, что ООП это сложно, лол

 5 

Ответить

[![User avatar](https://stepik.org/users/461108356/10f66f98ef2ddb053abab8c9ac01f817a68036db/avatar.svg)](https://stepik.org/users/461108356)

[Сергей Козлов](https://stepik.org/users/461108356)

в прошлом году

**@Павел_Хошев,** Что то у меня не сходится, мои манипуляции с кодом говорят что исключение прерывает выполнение всех задач которые не успели завершиться. Вот пожалуйста **мой** код:

```python
import asyncio

async def task_func(duration):
    print(f'Задача запущена, будет выполнена {duration} секунд.')
    await asyncio.sleep(duration)
    print(f'Задача завершена {duration}.')

async def main():
    task1 = asyncio.create_task(task_func(2))
    task2 = asyncio.create_task(task_func(5))
    # Ждем завершения первой задачи
    await task1

    # Здесь возникает исключение
    raise Exception("Произошла ошибка в main()")

    # Ждем завершения второй задачи
    await task2


asyncio.run(main())


Задача запущена, будет выполнена 2 секунд.
Задача запущена, будет выполнена 5 секунд.
Задача завершена 2.
Traceback (most recent call last):
  File "C:\Python\test1.py", line 21, in <module>
    asyncio.run(main())
  File "C:\Python\Python310\lib\asyncio\runners.py", line 44, in run
    return loop.run_until_complete(main)
  File "C:\Python\Python310\lib\asyncio\base_events.py", line 649, in run_until_complete
    return future.result()
  File "C:\Python\test1.py", line 15, in main
    raise Exception("Произошла ошибка в main()")
Exception: Произошла ошибка в main()
```

Как видим вторая задача запустилась но **не завершилась**, хотя вы писали что исключение  не препятствует корректному завершению задачи. И что значит "корректное завершение"? Мне на ум приходят два варианта 1-доисполнение кода корутины до исчерпания, 2- освобождение неких ресурсов, но т.к. их нет в примере то мы ничего не увидим.

Вот тут тоже не понятно, вы пишите:

> Обратите внимание на то, что, не смотря на возникшее исключение, в `main()` отработали и запустились обе задачи, `task1` и `task2`, о этой свидетельствует два сообщения "**Задача завершена**". "**Задача завершена**". Вторая задача `task2`, запустилась уже после возникшего исключения.

Вторая задача запустилась уже после возникшего исключения, НО ранее писали что задачи запускаются сразу после их создания. Может имелось ввиду что задача **завершилась** после возникновения исключения? В **вашем** примере это не так, задача уже завершилась ДО возникновения исключения и когда await task1 дождался завершения первой задачи вторая уже давно завершилась.

Показать полностью

 2 

ОтветитьПосмотреть 2 ответа (ответ преподавателя) 

[![User avatar](https://stepik.org/users/505469202/66940eb0e34e6d4d26f6b2617cc56874876c478c/avatar.svg)](https://stepik.org/users/505469202)

[Khaidar Zakirov](https://stepik.org/users/505469202)

в прошлом году

а с какой структурой данных работает event loop? Какая то структура данных должна ведь динамически наполняться событиями, задачами, колбеками и подпроцессами (из офф. документации)?

 1 

ОтветитьПосмотреть 4 ответа (ответ преподавателя) 

[![User avatar](https://cdn.stepik.net/media/users/538721399/1694673912-QceAUPx/avatar.png)](https://stepik.org/users/538721399)

[Никита Титов](https://stepik.org/users/538721399)

в прошлом году

_Важно знать, что `asyncio.run()` не может быть вызван_ внутри другой корутины или _в другом потоке_, так как это может привести к неожиданным результатам и ошибке. В таких случаях вы должны использовать другие методы asyncio, такие как `asyncio**.get_event_loop()**`. Это связано с тем, что _в каждом потоке может быть только один активный цикл событий_.  
  
Так может или не может быть вызван в разных потоках?  
  
Обратите внимание на то, что, не смотря на возникшее исключение, в `main()` отработали и запустились обе задачи, `task1` и `task2`, о**Б** это**М** свидетельству**Ю**т два сообщения "**Задача завершена**". "**Задача завершена**". Вторая задача `task2`, запустилась уже после возникшего исключения.  
  
Запустилась же она в момент создания таска, а после исключения мы только ожидаем ее завершения?

 1 

ОтветитьПосмотреть 2 ответа (ответ преподавателя) 

[![User avatar](https://stepik.org/users/571342596/ecf661046f884379a0d324d82fd37e744eff0059/avatar.svg)](https://stepik.org/users/571342596)

[Алексей Юрьевич Кадышев](https://stepik.org/users/571342596)

3 месяца назад

Не совсем понятно как работает оператор await. К примеру, если в коде п.6 await task1 и await task2 заменить на await asyncio.sleep(1), то обе задачи и запустятся и выполнятся, но если просто убрать запуск одной задачи о оставить только await task1, то вторая задача в этом случае не запустится. Почему в первом случае await запускает задачи, которые к await не относятся, а во втором нет?

ОтветитьПосмотреть 1 ответ (ответ преподавателя) 

[![User avatar](https://cdn.stepik.net/media/users/35582141/1700934722-tgSHSpx/avatar.png)](https://stepik.org/users/35582141)

[Alexey Alekseev](https://stepik.org/users/35582141)

в прошлом году

 > ```python
> import asyncio
> 
> async def coroutine_1():
>     await asyncio.sleep(1)
>     print("Корутина 1 выполнена")
> 
> async def coroutine_2():
>     await asyncio.sleep(2)
>     print("Корутина 2 выполнена")
> 
> async def main():
>     # Создаем задачи из корутин
>     task1 = asyncio.create_task(coroutine_1())
>     task2 = asyncio.create_task(coroutine_2())
>     
>     # Запускаем задачи и ждем их выполнения
>     await task1
>     await task2
>     print("Все корутины выполнены")
> 
> # Точка входа программы
> asyncio.run(main())
> ```

create_task создаёт и запускает

await - ждем завершения 

ОтветитьПосмотреть 11 ответов (ответ преподавателя) 

[![User avatar](https://stepik.org/users/83422533/acb239d5633c2effe81e7c9d81d6aaf539a4735e/avatar.svg)](https://stepik.org/users/83422533)

[Andrey Gulyayko](https://stepik.org/users/83422533)

в прошлом году

Видимо будет дальше, но хочу спросить сейчас

Зачем везде используется print()? Это постоянно сбивает с толку. Что нужно сделать, если я хочу вернуть какую-то переменную из main() или из любой другой корутины? Цикл событий может возвращать данные?

ОтветитьПосмотреть 8 ответов (ответ преподавателя) 

[![User avatar](https://stepik.org/users/390707563/79a727927f164ea2ff4f8513d90632d143b65252/avatar.svg)](https://stepik.org/users/390707563)

[Руслан Латипов](https://stepik.org/users/390707563)

в прошлом году

Если в корутине coroutine_1 увеличить время задержки больше чем в корутине coroutine_2.

То в этом случае coroutine_2 не будет запушена пока не выполниться coroutine_1.

Хотя в лекции ранее говорилось что обе коротины по идее должны запуститься одновременно.

Можно ли этот момент объяснить подробнее

Одновременный запуск корутин как я понял обеспечивает только метод asyncio.gather(*tasks)

![](https://ucarecdn.com/b2ea43af-a99f-4238-8ae8-3ee431439b6a/)

Показать полностью

ОтветитьПосмотреть 5 ответов (ответ преподавателя) 

[![User avatar](https://stepik.org/users/452232595/8737d8286eee0e7e34b06804548220f4bf68f941/avatar.svg)](https://stepik.org/users/452232595)

[Александр Чумиков](https://stepik.org/users/452232595)

в прошлом году

Подскажите, я правильно понял по указанным примерам, что, по сути, даже не делая явный try/except, всё равно всё отработает, т.к. исключение выбрасывается только после завершения всех корутин. Т.е., получается, что обработка исключения особо ни на что не влияет?

ОтветитьПосмотреть 1 ответ (ответ преподавателя) 

[![User avatar](https://cdn.stepik.net/media/users/554761453/avatar.png)](https://stepik.org/users/554761453)

[Сергей Томшин](https://stepik.org/users/554761453)

в прошлом году

Можете сориентировать: Запуск asyncio.run() в импортированном модуле вызовет ошибку, при наличии уже запущенного цикла событий?

Мой пример: Я использую асинхронный фреймворк(vkbottle), внутри его корутины я вызываю await методы своего класса, который я импортировал. Для реализации асинхронности внутри класса, я использовал asyncio.run() внутри инита(т.к. внутри класса запускаются его же методы). Все работает, но насколько это правильно

  1

ОтветитьПосмотреть 1 ответ (ответ преподавателя)