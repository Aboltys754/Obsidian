
1. Сохранение атрибутов `__name__` и `__doc__` для декорируемой функции
2. Применение декоратора `functools.wraps`
3. Шаблон декоратора общего назначения
4. Декоратор, измеряющий время выполнения функции
5. Декоратор отслеживания количества вызовов функции
6. Декоратор замедления времени выполнения функции
7. Декораторы с аргументами

## Сохранение атрибутов __name__ и __doc__ для декорируемой функции

Как мы уже знаем, все функции содержат специальные атрибуты `__name__` и `__doc__`, которые содержат полезную информацию:
- `__name__` — имя функции
- `__doc__` — строка документации

```python
def greet(name): '''Функция приветствия пользователя.''' 
	return f'Hello {name}!' 
print(greet.__name__) 
print(greet.__doc__)

>>> greet 
>>> Функция приветствия пользователя.
```
Рассмотрим применение декоратора `bold` к функции `greet()`.
```python
def bold(func): 
	def wrapper(*args, **kwargs): 
		return '<b>' + func(*args, **kwargs) + '</b>' 
	return wrapper 
	
@bold 
def greet(name): '''Функция приветствия пользователя.''' 
	return f'Hello {name}!' 
print(greet.__name__) 
print(greet.__doc__)

>>> wrapper 
>>> None
```
После того как к функции `greet()` был применен декоратор, её атрибуты `__name__` и `__doc__` изменились на имя и строку документации внутренней функции `wrapper()` декоратора `bold`. Хотя чисто технически это верно, это не очень хорошо.

Одно из решений такой проблемы выглядит следующим образом:
```python
def bold(func):
	def wrapper(*args, **kwargs): 
		return '<b>' + func(*args, **kwargs) + '</b>' 
	wrapper.__name__ = func.__name__ 
	wrapper.__doc__ = func.__doc__ 
	return wrapper 
	
@bold 
def greet(name): '''Функция приветствия пользователя.''' 
	return f'Hello {name}!' 
	
print(greet.__name__) 
print(greet.__doc__)

>>> greet 
>>> Функция приветствия пользователя.
```

## Применение декоратора functools.wraps

Для решения проблемы перетирания данных атрибутов на практике используют другой декоратор, который находится в модуле `functools` и называется `wraps`. Таким образом, чтобы предотвратить перетирание атрибутов `__name__` и `__doc__` декорируемой функции, декораторы должны использовать декоратор `functools.wraps`, который сохраняет информацию о первоначальной функции.

```python
import functools 

def bold(func): 
	@functools.wraps(func) 
	def wrapper(*args, **kwargs): 
		return '<b>' + func(*args, **kwargs) + '</b>' 
	return wrapper 
	
@bold 
def greet(name): '''Функция приветствие пользователя.''' 
	return f'Hello {name}!' 
print(greet.__name__) 
print(greet.__doc__)

>>> greet 
>>> Функция приветствие пользователя.
```
## Шаблон декоратора общего назначения

```python
import functools 

def decorator(func): 
	@functools.wraps(func) 
	def wrapper(*args, **kwargs): 
		# Что-то выполняется до вызова декорируемой функции 
		value = func(*args, **kwargs) 
		# декорируется возвращаемое значение функции 
		# или что-то выполняется после вызова декорируемой функции 
		return value 
	return wrapper
```
### Декоратор измерения времени работы функции


