
1. Определение декоратора
2. Специальный синтаксис применения декораторов
3. Изменение поведения функции
4. Применение нескольких декораторов
5. Декорирование функций, принимающих аргументы
6. Возврат значений из декорируемой функции

## Определение декоратора

**Декоратор** — это функция, которая принимает другую функцию, расширяет ее поведение, не изменяя ее явно, и возвращает новую функцию.

- функции являются объектами первого класса, то есть функции можно передавать и использовать в качестве аргументов;
- функции можно определять внутри других функций;
- вложенные функции могут использовать локальные переменные родительских функций;
- функции могут возвращать другие функции в качестве результата.

```python
def null_decorator(func): 
	return func

def say(): 
	print('Привет Мир!') 
	
say = null_decorator(say) # декорируем функцию 
say()

>>> Привет Мир!
```
## Специальный синтаксис применения декораторов

Использовать декораторы более простым способом с помощью символа `@`

```python
def sample_decorator(func): # определяем декоратор 
	def wrapper(): 
		print('Начало функции') 
		func() 
		print('Конец функции') 
	return wrapper 
	
def say(): 
	print('Привет Мир!') 	
say = sample_decorator(say) # декорируем функцию 
say()
-----------------------------------------------------------------
def sample_decorator(func): # определяем декоратор 
	def wrapper(): 
		print('Начало функции') 
		func() 
		print('Конец функции') 
	return wrapper 
@sample_decorator # декорируем функцию 
def say(): 
	print('Привет Мир!') 
say()
```
Иными словами, выражение `@sample_decorator` вызывает функцию `sample_decorator()` с `say` в качестве аргумента и присваивает имени `say` возвращаемую функцию.

Обратите внимание, что использование синтаксиса `@` декорирует функцию сразу во время определения. Это затрудняет доступ к недекорированной функции. Поэтому мы можем декорировать некоторые функции вручную, чтобы сохранить возможность вызывать и недекорированную версию функции.
## Изменение поведения функции

Декоратор может менять поведение декорируемой функции
```python
def uppercase_decorator(func): 
	def wrapper(): 
		original_result = func() 
		modified_result = original_result.upper() 
	return modified_result 
return wrapper
```
Вместо того чтобы просто возвращать исходную функцию, как это делал `null_decorator()`, декоратор `uppercase_decorator()` определяет и возвращает новую функцию `wrapper()`. Функция `wrapper()`, являясь замыканием, имеет доступ к недекорированной функции `func` и может выполнять дополнительный код до и после вызова функции `func`.

Декоратор `uppercase_decorator()` сам по себе является функцией. Единственный способ повлиять на новое поведение функции, которую он декорирует, — это заменить исходную функцию замыканием. Вот почему декоратор `uppercase_decorator()` определяет и возвращает другую функцию `wrapper()`, которую затем можно вызвать позже, запустить исходную функцию и изменить ее результат.

## Применение нескольких декораторов

Рассмотрим два декоратора `bold()` и `italic()`, которые заключают результат вызова функции в HTML-теги:
```python
def bold(func): 
	def wrapper(): 
		return '<b>' + func() + '</b>' 
	return wrapper 
	
def italic(func): 
	def wrapper(): 
		return '<i>' + func() + '</i>' 
	return wrapper


@bold 
@italic 
def greet(): 
	return 'Hello world!' 
print(greet())

>>> <b><i>Hello world!</i></b>
```
Декораторы применяются в порядке **снизу вверх**. Таким образом, мы можем явно использовать декорирование, обойдясь без специального синтаксиса. В таком случае цепочка вызовов функций декораторов будет выглядеть так:
```python
greet = bold(italic(greet))
```
## Декорирование функций, принимающих аргументы