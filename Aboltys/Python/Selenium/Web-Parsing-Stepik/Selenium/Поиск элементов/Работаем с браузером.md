Когда наш парсер отработает, мы бы хотели, чтобы он закрылся сам и тем самым корректно завершил свою работу. Но это может не произойти по множеству причин. Поэтому мы должны указать браузеру, что он должен закрыть окно после завершения работы, командой `driver.**quit()**`. Важно закрывать окно, потому что при создании `webdriver.Chrome()` создается процесс в **ОС**, который продолжит висеть. Команда `quit()` проще, чем закрывать окно браузера вручную, к тому же вы не будете засорять оперативную память.

Расставим таймауты в коде, чтобы видеть процесс выполнения кода и чтобы браузер не закрывался за мгновение.

```python
import time
from selenium import webdriver
from selenium.webdriver.common.by import By

driver= webdriver.Chrome()
driver.get('http://parsinger.ru/html/watch/1/1_1.html')
button = driver.find_element(By.ID, "sale_button")
time.sleep(2)
button.click()
time.sleep(2)
driver.quit()
```

Если ошибка произойдет во время выполнения кода до команды `.quit()` , сеанс **WebDriver** не будет закрыт должным образом, и файлы не будут удалены из памяти.

Для того, чтобы код гарантированно завершил свою работу командой  `driver.quit()`, используем конструкцию  `try/finally`. Весь код после `finally`: будет гарантированно выполнен.

```python
import time
from selenium import webdriver
from selenium.webdriver.common.by import By


try:
    driver= webdriver.Chrome()
    driver.get('http://parsinger.ru/html/watch/1/1_1.html')
    button = driver.find_element(By.ID, "sale_button")
    time.sleep(2)
    button.click()
    time.sleep(2)
finally:
    driver.quit()
```

Но есть еще третий способ, мой любимый, -  это менеджер контекста `with/as`. С этим способом нам вообще не нужно думать о том, когда закрывать браузер, менеджер контекста делает это за нас в тот момент, когда это нужно.

```python
import time
from selenium import webdriver
from selenium.webdriver.common.by import By

with webdriver.Chrome() as driver:
    driver.get('http://parsinger.ru/html/watch/1/1_1.html')
    button = driver.find_element(By.ID, "sale_button")
    time.sleep(2)
    button.click()
    time.sleep(2)
```

Выполните эти три примера у себя в терминале, чтобы посмотреть, как всё работает.

Самое время сказать, что вообще-то есть два похожих метода, которые часто путают новички: это `driver.close()` и `driver.quit()`. Сможете догадаться, чем они отличаются, не подглядывая в текст дальше?

`driver.close()` - закрывает текущее окно браузера, если во время работы вы открыли новое окно или вкладку.

`driver.quit()` - закрывает все окна, вкладки, процессы веб-драйвера, которые были запущены во время сессии.

**Некоторые проблемы WebDriver (из сети и личного опыта):**

- Поведение Selenium может отличаться в разных браузерах;
- Иногда возникают сложности с поиском элементов (XPath и другие методы иногда просто не работают, хотя должны);
- Необъяснимые падения драйвера прямо посреди работы скрипта;
- Взаимодействие возможно только с активной вкладкой браузера, хотя драйвер позволяет открывать новые вкладки и новые окна, но не позволяет одновременно в них работать, только поочерёдно.