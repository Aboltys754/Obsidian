
[[#XPath всегда начинается с символа / или //]]
[[#Правила фильтрации]]
[[#Символ * - Команда выбора всех элементов]]
[[#Поиск по классу в XPath]]


Когда возникает ситуация, где нам сложно найти уникальный CSS-селектор для нужного элемента, XPath становится отличной альтернативой. Этот метод позволяет искать элементы по их пути в дереве HTML-документа.

[XPath](https://ru.wikipedia.org/wiki/XPath) — это мощный и гибкий инструмент, но при этом потенциально рискованный.

1. Во-первых, с **XPath** можно составлять крайне сложные запросы для поиска элементов, что дает большую гибкость.
2. Во-вторых, если разработчик веб-сайта решит изменить структуру страницы, ваш парсер может сломаться, и искомый элемент будет утерян.

Также стоит отметить, что **XPath** использует древовидную структуру документа для поиска элементов. Проверить **XPath**-запрос можно так же, как и CSS-селекторы — через консоль разработчика в вашем браузере.

### XPath всегда начинается с символа / или //

- Символ `/` аналогичен символу `>` в CSS-селекторах, а символ `//` — пробелу в CSS.
    - `element1/element2` — выбирает элементы `element2`, которые являются прямыми потомками `element1`.
    - `element1//element2` — выбирает элементы `element2`, которые являются потомками `element1` на любом уровне вложенности.

Важная особенность: если начать **XPath**-запрос с символа `/`, корнем запроса всегда будет элемент с тегом `<html>`. Пример: `/html/body/header`.

Если же запрос начинается с `//`, это означает, что нужно найти все потомки корневого элемента, без уточнения, кто является корнем. Так, если нужно найти хедер, можно просто использовать `//header`, предполагая, что других элементов с таким названием на странице нет.

Для того чтобы на этой [странице](https://parsinger.ru/2.1/DOM/xpath_1.html) найти элемент `<h2>Подзаголовок в Статье</h2>` необходимо написать путь

```css
//article/header/h2[text()='Подзаголовок в Статье']
```

Этот XPath-запрос делает следующее:

1. `//article` - ищет все элементы `article` на странице, начиная с корневого элемента и далее по всему дереву.
2. `/header` - переходит к непосредственному дочернему элементу `header` каждого найденного `article`.
3. `/h2` - переходит к непосредственному дочернему элементу `h2` каждого найденного `header`.
4. `[text()='Подзаголовок в Статье']` - фильтрует элементы `h2` по их текстовому содержимому, оставляя только те, которые имеют текст "**Подзаголовок в Статье**".

![](https://ucarecdn.com/ea0d3994-694f-4696-8df4-bb9334510db6/)

**2.** **`[ ]` -** Команда для фильтрации элементов.

Когда по запросу найдено несколько элементов, XPath позволяет произвести фильтрацию согласно правилам, указанным в квадратных скобках `[ ]`.

## Правила фильтрации

- ### По атрибутам: 
	Фильтрация может быть произведена по любому атрибуту, такому как `id`, `class`, `title` и так далее. Например, если вы хотите найти ссылку с определенным `id`, запрос будет выглядеть следующим образом: `//a[@**id**='a_back']`. Здесь `@` указывает на атрибут, а `'a_back'` — это значение атрибута `id`, которое нам нужно.  
      
    [Сайт для проверки](https://parsinger.ru/html/watch/1/1_1.html) =>`//a[@**id**='a_back']`  
    ![](https://ucarecdn.com/dcf3dfdc-344d-4da0-9e31-20f496bcc214/)


- ### По порядковому номеру: 
	Эта возможность особенно полезна, если у вас есть список элементов, и вы хотите выбрать определенный по порядку. Например, чтобы выбрать пятый элемент `li` внутри `ul`, можно использовать запрос `//ul/li[5]`. В этом случае `[5]` указывает на то, что мы хотим взять именно пятый дочерний элемент.  
      
    [Сайт для проверки](https://parsinger.ru/html/watch/1/1_1.html) =>`//ul/li[5]`  
    ![](https://ucarecdn.com/551ecb10-30d2-4719-ae3b-732efab876a8/)
    

- ### По полному совпадению текста: 
	Если требуется найти элемент по точному текстовому содержанию, **XPath** является вашим единственным выбором. Применение данного метода хорошо иллюстрирует пример с поиском кнопки "Купить" при помощи XPath-селектора `//button[**text()**="Купить"]`. Стоит отметить, что такой запрос вернет элемент только в случае **полного совпадения** текста. И хотя этот метод может быть весьма эффективным, его использование не всегда является лучшей практикой, особенно если речь идет о мультиязычных сайтах.  
      
    [Сайт для проверки](https://parsinger.ru/html/watch/1/1_1.html)  = > `//button[**text()**="Купить"]`  
    ![](https://ucarecdn.com/c34504a4-6756-4b22-a8ac-11a072b19c9a/)  
     
- ### По частичному совпадению текста или атрибута: 
	Если вам нужно найти элементы, текст или атрибуты которых частично совпадают с заданным выражением, функция `contains` будет крайне полезной. Например, запрос `//p[**contains(**text(), "Артикул"**)**]` вернет все абзацы, содержащие слово "**Артикул**". Это может быть особенно полезно, если текст динамичен или содержит дополнительные символы и пробелы. Также метод применим для поиска по частичному совпадению атрибутов, что актуально, когда у элемента несколько классов. Если, скажем, в коде сайта есть тег `ul`, а внутри него теги `li` с атрибутами id, содержащими значения `material_frame` и `material_bracer`, то их можно найти селектором `//li[**contains(**@id, "material"**)**]`.
    
    - `//li` - Этот сегмент указывает на поиск всех элементов `<li>` на всех уровнях документа.  
    ​  ​​​​​​Двойной слеш `//` означает, что поиск ведется на всех уровнях вложенности, начиная от корневого узла.
    
     - `[contains(@id, "material")]` - Эта часть выражения уточняет критерии поиска для выбранных элементов `<li>`.  
       `contains()` - функция XPath, которая проверяет, содержит ли заданный атрибут указанное значение.  
     - `@id` - указывает на атрибут `id` элемента. Символ `@` используется для обозначения атрибута в XPath.  
     - `"material"` - это строковое значение, наличие которого проверяется в атрибуте id.
    
      
    [Сайт для проверки](https://parsinger.ru/html/watch/1/1_1.html)  = > `//li[**contains(**@id, "material"**)**]`и`//p[**contains(**text(), "Артикул"**)**]`   
    ![](https://ucarecdn.com/50c90937-7932-4c27-8ab2-fda9b68d3493/)

## Символ * - Команда выбора всех элементов

- В XPath символ `*` используется для выбора всех элементов, соответствующих заданному критерию. Это особенно полезно, если вы не знаете точный тег элемента, который пытаетесь найти. Допустим, вы хотите найти текст цены в определённом заголовке на сайте. В таком случае, запрос `//div/*[@class="price"]` будет искать все элементы внутри тега `div` с классом "**price**", независимо от их типа.  
      
    Этот способ удобен для широкого поиска, однако важно помнить, что такая "широкая сеть" может ловить и нежелательные элементы. В нашем примере найдено 8 элементов, что уже подсказывает о том, что следует быть осторожным и, возможно, уточнить критерии поиска.  
      
    [Сайт для проверки](https://parsinger.ru/html/index1_page_1.html#1_1)  = > `//div/*[@class="price"]`  
    ![](https://ucarecdn.com/eaaa9ed4-01f7-42ab-a201-ec723fb1fc97/)
- ​

## Поиск по классу в XPath
pависит от регистра

Очень важным аспектом при использовании XPath является чувствительность к регистру. Это значит, что при поиске элементов по классам необходимо строго соблюдать регистр символов.

Пример: запрос `//div/*[@class="**P**rice"]` не обнаружит элемент на странице, если его класс указан как "price" с маленькой буквы "p". Этот момент может стать "ловушкой" для незнающих данную особенность разработчиков и аналитиков данных.

![](https://ucarecdn.com/07e99fa4-6681-4256-bf99-f2d9664830cc/)

Что важно знать про **XPath**, чтобы пользоваться им, безболезненно:

- Избегайте сложных и непонятных селекторов типа `//div[1]/div[2]/div[3].` Такие селекторы не только сложно читать, но и сильно зависят от структуры веб-страницы. Если разработчики изменят расположение элементов, ваш парсер, скорее всего, перестанет работать.  
     
- Предпочтение CSS-селекторам: Если у вас есть возможность использовать CSS-селекторы — такие как **class**, **id** или **name** — лучше придерживаться их. Они более наглядны и, как правило, менее подвержены изменениям на сайте.
    
    ```css
    # Используйте это 
    //button[@id='clickMe']
    
    # Вместо этого
    //div[1]/div[2]/div[3]
    ```
    
- Поиск по тексту и атрибутам: XPath позволяет выполнять поиск по полному или частичному совпадению текста и любых атрибутов. Это может быть полезно, но помните, что такой метод может быть нестабильным, особенно на мультиязычных сайтах.
    
    ```python
    # Поиск по полному совпадению текста
    # Этот XPath выберет кнопку с текстом "Купить".
    //button[text()="Купить"]
    
    # Поиск по частичному совпадению текста
    # Этот XPath выберет все элементы p, в которых содержится текст "Артикул".
    //p[contains(text(), "Артикул")]
    
    
    # Поиск по полному совпадению атрибута
    # Этот XPath выберет все ссылки, у которых атрибут href равен "https://example.com".
    //a[@href="https://example.com"]
    
    
    # Поиск по частичному совпадению атрибута
    # Этот XPath выберет все элементы li с классом, который частично совпадает с "item".
    //li[contains(@class, "item")]
    ```
    
- Навигация по документу: Одним из преимуществ XPath является удобная навигация по структуре документа. Вы можете легко переходить от родителей к потомкам и обратно, что может быть полезно при сложных задачах парсинга.
    
    ```python
    # Переход к дочерним элементам
    # Здесь мы находим все дочерние элементы div с id='parent'.
    //div[@id='parent']/child::*
    
    # Переход к родительскому элементу
    # Этот запрос вернет родительский элемент div с id='child'.
    //div[@id='child']/parent::*
    
    # Переход к следующему соседнему элементу
    # Этот запрос вернет все следующие соседние элементы после div с id='prev_sibling'.
    //div[@id='prev_sibling']/following-sibling::*
    
    # Переход к предыдущему соседнему элементу
    # Этот запрос вернет все предыдущие соседние элементы перед div с id='next_sibling'.
    //div[@id='next_sibling']/preceding-sibling::*
    
    # Переход к конкретному дочернему элементу
    # Этот запрос вернет первый дочерний элемент p у div с id='parent'.
    //div[@id='parent']/child::p[1]
    
    # Поиск по вложенным элементам
    # Этот запрос вернет все элементы span, являющиеся потомками div с id='ancestor'.
    //div[@id='ancestor']//child::span
    ```
    
- При отсутствии атрибутов: Если у сайта плохо с атрибутами, XPath становится вашим спасением. Он позволяет искать элементы по их структурному расположению, что может быть единственным выходом в некоторых случаях.  
     
    
    ```python
    # Поиск первого дочернего элемента
    # Этот запрос вернет первые дочерние элементы для всех div.
    //div/*[1]
    
    # Поиск последнего дочернего элемента
    # Здесь мы находим последние дочерние элементы для всех div.
    //div/*[last()]
    
    # Поиск по порядковому номеру
    # Этот запрос вернет третий элемент li в каждом ul.
    //ul/li[position()=3]
    
    # Поиск элементов, имеющих дочерние элементы
    # Этот запрос вернет все div, которые имеют хотя бы одного потомка.
    //div[count(*) > 0]
    
    # Поиск элементов на определенной глубине
    # Этот запрос вернет все элементы p, находящиеся на четвертом уровне вложенности.
    //*/*/*/*[name()='p']
    ```
    
- Остерегайтесь автоматических генераторов XPath: Использование различных расширений для браузера для автоматического создания XPath-селекторов может привести к генерации переусложненных и нечитаемых селекторов. Намного лучше потратить время и разобраться в синтаксисе самостоятельно. Он не так уж и сложен, а понимание придет с опытом.  
      
    **Переусложнение Селекторов**  
    Расширения для браузеров могут создать слишком детализированные или вложенные селекторы, которые трудно понять и поддерживать.
    
    ```less
    # Пример нежелательного селектора:
    /html/body/div[1]/section/div[1]/div/div/div[3]/button
    ```
    
    **Нечитаемость**  
    Сложно понять, что именно делает такой селектор. Это делает дебаггинг и поддержку кода очень трудными.  
    **Хрупкость**  
    Такие селекторы очень чувствительны к любым изменениям на веб-странице. Даже небольшие изменения в структуре могут "сломать" ваш парсинг."  
      
    Стандартный и в то же время самый простой способ получить **XPath** в Сhrome.  
    ![](https://ucarecdn.com/c3fd31bc-b67a-4bf9-8b1b-e9835197e622/)


```html
# Вернет все ссылка во всех элементах а
//a[@href]/@href
```