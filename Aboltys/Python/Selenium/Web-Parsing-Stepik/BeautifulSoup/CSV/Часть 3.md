
В этом уроке мы будем получать данные сразу с восьми карточек одновременно. Как говорится, следите за руками.

Мы хотим получить аккуратно отформатированные данные, лежащие в таблице **excel**, примерно вот так:

![](https://ucarecdn.com/f1d6bf94-b740-41c4-8974-f3b3e2eb0fa1/)

Откроем [тренажер](http://parsinger.ru/html/index3_page_2.html) и соберем с каждой карточки следующую информацию как на скриншоте ниже:

![](https://ucarecdn.com/77f86a5e-08fe-4ec0-8463-b202b0b55a72/)

Для начала посмотрим на структуру данной карточки, а конкретно на теги `<li>`. Мы видим,  что у всех необходимых нам элементов есть то, за что можно зацепиться. У каждого элемента есть  свой `class=''`, а у тегов `<li>` ничего нет, только родительский элемент `<div class='description'>` . По нему мы и будем получать наши элементы `<li>`, причем все и сразу.

Мы могли бы использовать код `soup.find('div', class_='description').find_all('li')`,  т.е., попросили бы наш интерпретатор найти блок `div` с классом `description` и в нем отыскать все теги `<li>`. Это отличный подход для одной карточки, а у нас их восемь. Это значит, что нам нужно искать все теги `div` с классом `description`  на странице одновременно.

![](https://ucarecdn.com/fc1671ba-e247-4eeb-8f59-984fe8e0117e/)

 Давайте посмотрим на код целиком:

- В переменной  `name` у нас будет храниться список наименований товаров;
- В переменной  `description` у нас будет храниться **список списков** описания товаров, которые находятся в `<li>`;
- В переменной  `price` у нас будет храниться список цен товаров.

Наша задача - объединить эти 3 списка в 1 список или кортеж, избегая вложенных списков. Если мы просто объединим эти три списка, мы получим![](https://ucarecdn.com/43a513df-cb37-4912-b65c-3a41752c1af0/)

Мы знаем, что модуль **CSV** может спокойно работать с вложенными списками. Но результат будет не тот, который мы ожидаем, - посмотрите на изображение ниже. Поэтому нам нужно извлечь вложенный список.![](https://ucarecdn.com/2985bf96-cd7a-4b1b-8f54-d48fbfa23fbe/)

Блок №4 в коде ниже, решает эту задачу. В результате выполнения блока №4 мы получаем новый список `flatten` , который выглядит как нужно ![](https://ucarecdn.com/f7934258-8c08-4a71-8420-6d54dd9e0afe/)

Такой список мы можем спокойно записать в файл, не опасаясь, что таблица уедет. Передадим список в метод `.writerow(result)` и полюбуемся результатом. Запустите данный код у себя в терминале.

```python
import csv
import requests
from bs4 import BeautifulSoup

# 1 ------------------------------------------------------
with open('res.csv', 'w', encoding='utf-8-sig', newline='') as file:
    writer = csv.writer(file, delimiter=';')
    writer.writerow([
        'Наименование', 'Цена', 'Бренд', 'Тип', 'Подключение', 'Игровая'])
# 1 ------------------------------------------------------

# 2 ------------------------------------------------------
url = 'http://parsinger.ru/html/index3_page_2.html'

response = requests.get(url=url)
response.encoding = 'utf-8'
soup = BeautifulSoup(response.text, 'lxml')
# 2 ------------------------------------------------------

# 3 ------------------------------------------------------
# Извлекаем имена товаров и убираем лишние пробелы
name = [x.text.strip() for x in soup.find_all('a', class_='name_item')]

# Извлекаем описание товаров и разбиваем на строки
description = [x.text.split('\n') for x in soup.find_all('div', class_='description')]

# Извлекаем цены товаров
price = [x.text for x in soup.find_all('p', class_='price')]
# 3 ------------------------------------------------------


# 4------------------------------------------------------
# Открываем файл для дополнительной записи данных
with open('res.csv', 'a', encoding='utf-8-sig', newline='') as file:
    writer = csv.writer(file, delimiter=';')
    for item, price, descr in zip(name, price, description):

        # Формируем строку для записи
        flatten = item, price, *[x.split(':')[1].strip() for x in descr if x]
        writer.writerow(flatten)

print('Файл res.csv создан')
```

 Этот код создаёт [файл](https://stepik.org/media/attachments/lesson/701336/res.csv).  
![](https://ucarecdn.com/572df8e0-556b-47ac-8a86-ac157d546e8e/)

#### Блок кода 1:

Этот блок кода отвечает за создание нового CSV-файла и запись в него строки заголовков. Строка заголовков состоит из названий столбцов, таких как `"Наименование"`, `"Цена"`, `"Бренд"` и так далее.

#### Блок кода 2:

В этом блоке происходит запрос веб-страницы с интернета и её последующий парсинг. Здесь используются библиотеки `requests` для скачивания страницы и `BeautifulSoup` из пакета `bs4` для парсинга HTML-кода страницы.

#### Блок кода 3:

Здесь извлекаются определённые данные с веб-страницы. С помощью `BeautifulSoup` код находит все нужные элементы на странице — имена товаров, их описания и цены, — и сохраняет их в соответствующие списки.

#### Блок кода 4:

Этот блок кода отвечает за запись извлечённых данных в ранее созданный CSV-файл. Для каждого товара формируется строка, состоящая из его имени, цены и характеристик, которая затем записывается в файл. После успешного завершения всех операций выводится сообщение о том, что файл успешно создан.