1. Функции высшего порядка
2. Самописные функции 
	- `map()`: преобразование элементов списка;
	- `filter()`: фильтрация элементов списка;
	- `reduce()`: агрегация элементов списка.

## Функции высшего порядка

Как уже сказано, функции, которые принимают или/и возвращают другие функции, называются **функциями высшего порядка**.

```python
def high_order_function(func): # функция высшего порядка, так как принимает функцию 
	return func(3)
```
Здесь функция `high_order_function()` принимает другую функцию на входе и возвращает результат её вызова с аргументом, равным 3.

## Функции высшего порядка для обработки набора данных

Часто функции высшего порядка используются для обработки наборов данных. Рассмотрим три важные функции высшего порядка:

- `map()`;
- `filter()`;
- `reduce()`.
### Функция map()
При работе со списками часто требуется применить одно и то же преобразование к каждому элементу. Можно написать цикл, содержащий нужное преобразование.

Например, для преобразования списка чисел в список их квадратов, код может выглядеть так:
```python
def f(x): 
	return x**2 # тело функции, которая преобразует аргумент x 
old_list = [1, 2, 4, 9, 10, 25] 
new_list = []

for item in old_list: 
	new_item = f(item) 
	new_list.append(new_item)
	
print(old_list) 
print(new_list)

>>> [1, 2, 4, 9, 10, 25] 
>>> [1, 4, 16, 81, 100, 625]
```
Несложно понять, что цикл будет выглядеть одинаково практически во всех случаях. Меняться будет только преобразование, то есть применяемая функция `f()`. Так почему бы не обобщить код, чтобы функция была параметром? Так и сделаем:
```python
def map(function, items): 
	result = [] 
	for item in items: 
		new_item = function(item) 
		result.append(new_item) 
	return result

def square(x): 
	return x**2 
	
def cube(x): 
	return x**3 
	
numbers = [1, 2, -3, 4, -5, 6, -9, 0] 
strings = map(str, numbers) # используем в качестве преобразователя - функцию str 
abs_numbers = map(abs, numbers) # используем в качестве преобразователя - функцию abs
squares = map(square, numbers) # используем в качестве преобразователя - функцию square
cubes = map(cube, numbers) # используем в качестве преобразователя - функцию cube 

print(strings) 
print(abs_numbers) 
print(squares) 
print(cubes)

>>> ['1', '2', '-3', '4', '-5', '6', '-9', '0'] 
>>> [1, 2, 3, 4, 5, 6, 9, 0] 
>>> [1, 4, 9, 16, 25, 36, 81, 0] 
>>> [1, 8, -27, 64, -125, 216, -729, 0]
```
Реализованную нами функцию `map()` можно использовать как альтернативную возможность для преобразования типов элементов любого списка. Раньше мы решали такую задачу с помощью списочных выражений. Теперь можем использовать и функцию `map()`.
```python
strings = ['10', '12', '-4', '-9', '0', '1', '23', '100', '99'] 
numbers1 = [int(c) for c in strings] # используем списочное выражение для преобразования 
numbers2 = map(int, strings) # используем функцию map() для преобразования
print(numbers1) 
print(numbers2)

>>> [10, 12, -4, -9, 0, 1, 23, 100, 99] 
>>> [10, 12, -4, -9, 0, 1, 23, 100, 99]
```
### Функция filter()

Другая популярная задача при работе со списками: отобрать часть элементов списка по определенному критерию. Функция высшего порядка для решения такой задачи называется `filter()`.

Функция-критерий, которая возвращает значение `True` или `False`, называется предикатом.
```python
def filter(function, items): 
	result = [] 
	for item in items: 
		if function(item): 
			result.append(item) # добавляем элемент item если функция function вернула значение True 
	return result
```
Наша функция `filter()` применяет предикат `function` к каждому элементу и добавляет в итоговый список только те элементы, для которых предикат вернул `True`.

### Функция reduce()

Реализованные нами функции `map()` и `filter()` работали с отдельными элементами списка независимо. Но встречаются циклы с агрегацией результата — формированием одного результирующего значения при комбинации элементов с использованием аргумента-аккумулятора.

```python
numbers = [1, 2, 3, 4, 5] 
total = 0 
product = 1 
for num in numbers: 
	total += num 
	product *= num 
print(total) 
print(product)

>>> 15 
>>> 120
```
Несложно понять, что этот цикл будет выглядеть одинаково практически во всех случаях. Меняться будет только начальное значение аккумулятора (00 для суммы, 11 для произведения и т.д.) и операция, которая комбинирует элемент и аккумулятор. Так почему бы не обобщить этот код? Так и сделаем:

```python
def reduce(operation, items, initial_value): 
	acc = initial_value 
	for item in items: 
		acc = operation(acc, item) 
	return acc
```
```python
def add(x, y): 
	return x+y 
def mult(x, y): 
	return x*y 
numbers = [1, 2, 3, 4, 5] 
total = reduce(add, numbers, 0) 
product = reduce(mult, numbers, 1) 
print(total) 
print(product)

>>> 15 
>>> 120
```


